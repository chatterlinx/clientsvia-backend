/**
 * Company Knowledge Service - V2 Production System
 * Handles Company Q&A CRUD operations with Redis caching and AI agent integration
 * 
 * ðŸ¤– AI AGENT ROUTING REFERENCE:
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘ CORE SERVICE FOR PRIORITY #1 KNOWLEDGE SOURCE ROUTING           â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘ AI Agent Flow: Question â†’ this.findAnswerForAIAgent()           â•‘
 * â•‘ â”œâ”€ Step 1: Check Redis cache (knowledge:company:{id}:search:{hash}) â•‘
 * â•‘ â”œâ”€ Step 2: Query CompanyQnA model with semantic matching        â•‘
 * â•‘ â”œâ”€ Step 3: Score relevance using keywords + text similarity     â•‘
 * â•‘ â”œâ”€ Step 4: Return confidence score + answer if above threshold  â•‘
 * â•‘ â””â”€ Step 5: Cache result for future queries                      â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ðŸ”„ TROUBLESHOOTING REFERENCE:
 * â€¢ Entry Point: /routes/aiAgentLogic.js line ~1037
 * â€¢ API Endpoint: POST /api/ai-agent/company-knowledge/:companyId
 * â€¢ Test Endpoint: POST /api/ai-agent/test-priority-flow/:companyId
 * â€¢ Cache Issues: Check Redis connection status in logs
 * â€¢ Performance: Monitor this.performanceMetrics for latency
 * â€¢ Keywords: Generated by KeywordGenerationService using NLP
 * 
 * ðŸš¨ CRITICAL FOR AI ROUTING:
 * - findAnswerForAIAgent() method is the primary integration point
 * - Confidence threshold determines routing to next priority level
 * - Redis caching critical for production performance
 * - Error handling ensures graceful fallback without cache
 */

const CompanyKnowledgeQnA = require('../../models/knowledge/CompanyQnA');
const KeywordGenerationService = require('./KeywordGenerationService');
// V2 DELETED: Legacy natural NLP library - using V2 keyword-based system
// const natural = require('natural');
const winston = require('winston');

// Initialize Redis client
const redis = require('redis');
let redisClient = null;

// Initialize logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/knowledge-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/knowledge-combined.log' }),
    new winston.transports.Console({ format: winston.format.simple() })
  ]
});

class CompanyKnowledgeService {
  constructor() {
    this.keywordService = new KeywordGenerationService();
    this.performanceMetrics = {
      cacheHits: 0,
      cacheMisses: 0,
      searchLatency: [],
      totalQueries: 0
    };
    
    this.initializeRedis();
  }

  /**
   * ðŸ”— REDIS INITIALIZATION WITH FALLBACK
   */
  async initializeRedis() {
    try {
      // Redis v5+ URL-based connection format
      const redisUrl = process.env.REDIS_URL || 
        `redis://${process.env.REDIS_PASSWORD ? `:${process.env.REDIS_PASSWORD}@` : ''}${process.env.REDIS_HOST || 'localhost'}:${process.env.REDIS_PORT || 6379}`;
      
      redisClient = redis.createClient({
        url: redisUrl,
        socket: {
          reconnectStrategy: (retries) => {
            if (retries > 3) {
              logger.warn('Redis max reconnection attempts reached. Operating without cache.');
              return false; // Stop retrying
            }
            return Math.min(retries * 100, 3000);
          }
        }
      });

      redisClient.on('connect', () => {
        logger.info('âœ… Redis connected successfully');
      });

      redisClient.on('error', (err) => {
        logger.warn('âš ï¸ Redis error:', err.message, '- Operating without cache');
        redisClient = null; // Disable Redis operations
      });

      // Connect to Redis (required in v5+)
      await redisClient.connect();
      
      // Test connection
      await redisClient.ping();
      logger.info('ðŸš€ CompanyKnowledgeService initialized with Redis caching');

    } catch (error) {
      logger.warn('âš ï¸ Redis initialization failed:', error.message, '- Operating without cache');
      redisClient = null;
    }
  }

  /**
   * ðŸŽ¯ AI AGENT INTEGRATION: SMART Q&A LOOKUP
   * This is the main method called by the AI agent during conversations
   * 
   * ðŸ¤– AI ROUTING: PRIMARY INTEGRATION POINT FOR PRIORITY #1 SOURCE
   * Called from: /routes/aiAgentLogic.js â†’ /api/ai-agent/company-knowledge/:companyId
   * Flow: Redis cache â†’ Mongoose query â†’ Semantic scoring â†’ Confidence check
   */
  async findAnswerForAIAgent(query, companyId, options = {}) {
    const startTime = Date.now();
    this.performanceMetrics.totalQueries++;
    
    try {
      logger.info(`ðŸ¤– AI Agent Query: "${query}" for company ${companyId}`);
      
      const {
        minConfidence = 0.7,
        maxResults = 3,
        includeAnalytics = false
      } = options;

      // Step 1: Try Redis cache first (ultra-fast)
      const cacheKey = this.generateCacheKey(query, companyId, { minConfidence });
      const cachedResult = await this.getCachedResult(cacheKey);
      
      if (cachedResult) {
        this.performanceMetrics.cacheHits++;
        const responseTime = Date.now() - startTime;
        this.performanceMetrics.searchLatency.push(responseTime);
        
        logger.info(`âš¡ Cache hit for AI agent query (${responseTime}ms)`);
        
        return {
          ...cachedResult,
          responseTime,
          source: 'cache',
          cacheHit: true
        };
      }

      // Step 2: Generate keywords from query
      const queryKeywords = await this.keywordService.generateAdvancedKeywords(
        query, 
        '', // No answer text for queries
        { companyId }
      );

      // Step 2.1: Build or load per-company phonetic dictionary for trade terms
      const phoneticDict = await this.getCompanyPhoneticDictionary(companyId);
      // V2 DELETED: Legacy natural Metaphone - using V2 keyword matching
      // const metaphone = natural.Metaphone;

      // Create a trade-scoped fuzzy set from the generated query keywords
      const expandedQueryKeywords = new Set(queryKeywords.primary);
      queryKeywords.primary.forEach(token => {
        // V2 SYSTEM: Simple lowercase key instead of metaphone
        const key = token.toLowerCase().trim();
        const expansions = phoneticDict[key] || [];
        expansions.forEach(exp => expandedQueryKeywords.add(exp));
      });

      // Step 3: Search database with optimized query
      const searchResults = await this.performOptimizedSearch(
        Array.from(expandedQueryKeywords),
        companyId,
        { minConfidence, maxResults }
      );

      // Step 4: Score and rank results
      const rankedResults = this.scoreAndRankResults(searchResults, query, queryKeywords.primary);

      // Step 5: Cache the result for next time
      if (rankedResults.length > 0) {
        await this.cacheResult(cacheKey, rankedResults, 3600); // Cache for 1 hour
      }

      this.performanceMetrics.cacheMisses++;
      const responseTime = Date.now() - startTime;
      this.performanceMetrics.searchLatency.push(responseTime);

      logger.info(`ðŸ” Database search completed for AI agent (${responseTime}ms) - Found ${rankedResults.length} matches`);

      // Step 6: Update usage analytics
      if (rankedResults.length > 0 && includeAnalytics) {
        this.updateUsageAnalytics(rankedResults[0]._id, query, responseTime);
      }

      return {
        results: rankedResults,
        responseTime,
        source: 'database',
        cacheHit: false,
        query: query,
        keywords: Array.from(new Set([...(queryKeywords.primary || [])])),
        keywordMatchCount: rankedResults[0]?.keywordMatches ?? 0,
        phoneticSimilarity: rankedResults[0]?.phoneticSimilarity ?? 0,
        totalFound: rankedResults.length,
        confidence: rankedResults[0]?.confidence || 0
      };

    } catch (error) {
      const responseTime = Date.now() - startTime;
      logger.error('âŒ AI Agent query failed:', error);
      
      return {
        results: [],
        responseTime,
        source: 'error',
        error: error.message,
        cacheHit: false
      };
    }
  }

  /**
   * âš¡ OPTIMIZED DATABASE SEARCH
   */
  async performOptimizedSearch(keywords, companyId, options = {}) {
    const { minConfidence = 0.7, maxResults = 5 } = options;
    
    try {
      // Use the static method from the model with optimized query
      const results = await CompanyKnowledgeQnA.searchByKeywords(keywords, companyId, {
        limit: maxResults,
        minConfidence,
        categories: options.categories || [],
        tradeCategories: options.tradeCategories || []
      });

      return results;

    } catch (error) {
      logger.error('Database search failed:', error);
      throw error;
    }
  }

  /**
   * ðŸ“Š INTELLIGENT RESULT SCORING
   */
  scoreAndRankResults(results, originalQuery, keywords) {
    return results.map(result => {
      // Calculate relevance score
      const keywordMatches = this.countKeywordMatches(result.keywords, keywords);
      const questionSimilarity = this.calculateStringSimilarity(originalQuery, result.question);
      const phoneticSimilarity = this.phoneticSimilarity(originalQuery, result.question);
      const usageScore = Math.min(result.usageCount / 100, 1); // Normalize usage count
      
      // Weighted scoring
      const relevanceScore = (
        (keywordMatches * 0.35) +
        (questionSimilarity * 0.35) +
        (phoneticSimilarity * 0.15) +
        (result.confidence * 0.1) +
        (usageScore * 0.05)
      );

      return {
        ...result,
        relevanceScore,
        keywordMatches,
        questionSimilarity,
        phoneticSimilarity
      };
    }).sort((a, b) => b.relevanceScore - a.relevanceScore);
  }

  /**
   * ðŸ“ COMPANY Q&A CRUD OPERATIONS
   */

  // Create new Q&A entry
  async createQnA(companyId, qnaData, userId = null) {
    try {
      console.log('ðŸ§  CHECKPOINT: CompanyKnowledgeService.createQnA started');
      console.log('ðŸ§  CHECKPOINT: Input data:', { companyId, userId, qnaData });
      
      logger.info(`ðŸ“ Creating new Q&A for company ${companyId}`);

      console.log('ðŸ§  CHECKPOINT: Creating new CompanyQnA instance');
      const qna = new CompanyQnA({
        ...qnaData,
        companyId,
        createdBy: userId,
        lastModifiedBy: userId
      });

      console.log('ðŸ§  CHECKPOINT: Running validation');
      // Validate before saving
      await qna.validate();
      
      console.log('ðŸ§  CHECKPOINT: Validation passed, attempting save');
      // Save (triggers keyword generation middleware)
      const savedQnA = await qna.save();
      
      console.log('ðŸ§  CHECKPOINT: Q&A saved successfully, invalidating caches');
      // Invalidate relevant caches
      await this.invalidateCompanyCaches(companyId);
      
      console.log('âœ… CHECKPOINT: Q&A creation completed successfully');
      logger.info(`âœ… Q&A created successfully: ${savedQnA._id}`);
      
      return {
        success: true,
        data: savedQnA,
        message: 'Q&A entry created successfully'
      };

    } catch (error) {
      console.error('âŒ CRITICAL: CompanyKnowledgeService.createQnA failed:');
      console.error('âŒ CHECKPOINT: Error message:', error.message);
      console.error('âŒ CHECKPOINT: Error stack:', error.stack);
      console.error('âŒ CHECKPOINT: Error name:', error.name);
      console.error('âŒ CHECKPOINT: Input data that caused error:', { companyId, userId, qnaData });
      
      logger.error('âŒ Failed to create Q&A:', error);
      
      return {
        success: false,
        error: error.message,
        details: error.errors || {},
        checkpoint: 'CompanyKnowledgeService.createQnA method failed'
      };
    }
  }

  // Get all Q&As for a company with pagination and filtering
  async getCompanyQnAs(companyId, options = {}) {
    try {
      const {
        page = 1,
        limit = 20,
        category = null,
        status = null,  // Changed default to null for emergency access
        search = null,
        sortBy = 'updatedAt',
        sortOrder = -1
      } = options;

      const query = {
        companyId
      };
      
      // Only add status filter if status is specified (not undefined for 'all')
      if (status !== undefined && status !== null) {
        query.status = status;
      }
      
      console.log('ðŸ” CHECKPOINT: MongoDB query for Q&A entries:', query);

      // Add filters
      if (category) query.category = category;
      if (search) {
        query.$or = [
          { question: { $regex: search, $options: 'i' } },
          { answer: { $regex: search, $options: 'i' } },
          { keywords: { $in: [new RegExp(search, 'i')] } }
        ];
      }

      // Execute query with pagination
      const skip = (page - 1) * limit;
      const [results, total] = await Promise.all([
        CompanyKnowledgeQnA.find(query)
          .sort({ [sortBy]: sortOrder })
          .skip(skip)
          .limit(limit)
          .lean(),
        CompanyKnowledgeQnA.countDocuments(query)
      ]);

      return {
        success: true,
        data: results,
        pagination: {
          current: page,
          pages: Math.ceil(total / limit),
          total,
          limit
        }
      };

    } catch (error) {
      logger.error('âŒ Failed to get company Q&As:', error);
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Update Q&A entry
  async updateQnA(qnaId, updateData, userId = null) {
    try {
      console.log('ðŸ§  CHECKPOINT: CompanyKnowledgeService.updateQnA called');
      console.log('ðŸ§  CHECKPOINT: Q&A ID:', qnaId);
      console.log('ðŸ§  CHECKPOINT: Update data received:', updateData);
      console.log('ðŸ§  CHECKPOINT: Status in update data:', updateData.status);
      
      logger.info(`âœï¸ Updating Q&A: ${qnaId}`);

      const qna = await CompanyKnowledgeQnA.findById(qnaId);
      if (!qna) {
        console.error('âŒ CHECKPOINT: Q&A entry not found in database');
        return {
          success: false,
          error: 'Q&A entry not found'
        };
      }

      console.log('âœ… CHECKPOINT: Q&A found in database');
      console.log('ðŸ§  CHECKPOINT: Current Q&A status:', qna.status);
      console.log('ðŸ§  CHECKPOINT: New status to set:', updateData.status);

      // Update fields
      Object.assign(qna, updateData);
      qna.lastModifiedBy = userId;
      
      console.log('ðŸ§  CHECKPOINT: Fields assigned, Q&A status after assign:', qna.status);
      console.log('ðŸ§  CHECKPOINT: About to save Q&A to database');
      
      // Save (triggers keyword regeneration if question/answer changed)
      const updatedQnA = await qna.save();
      
      console.log('âœ… CHECKPOINT: Q&A saved to database successfully');
      console.log('ðŸ§  CHECKPOINT: Final Q&A status in database:', updatedQnA.status);
      
      // Invalidate caches
      await this.invalidateCompanyCaches(qna.companyId);
      console.log('âœ… CHECKPOINT: Redis caches invalidated');
      
      logger.info(`âœ… Q&A updated successfully: ${qnaId}`);
      
      return {
        success: true,
        data: updatedQnA,
        message: 'Q&A entry updated successfully'
      };

    } catch (error) {
      logger.error('âŒ Failed to update Q&A:', error);
      
      return {
        success: false,
        error: error.message,
        details: error.errors || {}
      };
    }
  }

  // Delete Q&A entry (soft delete)
  async deleteQnA(qnaId, userId = null) {
    try {
      logger.info(`ðŸ—‘ï¸ Deleting Q&A: ${qnaId}`);

      const result = await CompanyKnowledgeQnA.findByIdAndUpdate(
        qnaId,
        { 
          status: 'archived',
          lastModifiedBy: userId,
          archivedAt: new Date()
        },
        { new: true }
      );

      if (!result) {
        return {
          success: false,
          error: 'Q&A entry not found'
        };
      }

      // Invalidate caches
      await this.invalidateCompanyCaches(result.companyId);
      
      logger.info(`âœ… Q&A archived successfully: ${qnaId}`);
      
      return {
        success: true,
        message: 'Q&A entry archived successfully'
      };

    } catch (error) {
      logger.error('âŒ Failed to delete Q&A:', error);
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * ðŸ”„ CACHE MANAGEMENT
   */
  
  generateCacheKey(query, companyId, options = {}) {
    const { minConfidence = 0.7 } = options;
    const normalizedQuery = query.toLowerCase().trim().replace(/\s+/g, ' ');
    return `company:${companyId}:qna:${Buffer.from(normalizedQuery).toString('base64')}:conf:${minConfidence}`;
  }

  async getCachedResult(cacheKey) {
    if (!redisClient) return null;
    
    try {
      const cached = await redisClient.get(cacheKey);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      logger.warn('Cache read error:', error.message);
      return null;
    }
  }

  async cacheResult(cacheKey, result, ttl = 3600) {
    if (!redisClient) return;
    
    try {
      await redisClient.setex(cacheKey, ttl, JSON.stringify(result));
    } catch (error) {
      logger.warn('Cache write error:', error.message);
    }
  }

  async invalidateCompanyCaches(companyId) {
    if (!redisClient) return;
    
    try {
      const pattern = `company:${companyId}:qna:*`;
      const keys = await redisClient.keys(pattern);
      
      if (keys.length > 0) {
        await redisClient.del(...keys);
        logger.info(`ðŸ—‘ï¸ Invalidated ${keys.length} cache entries for company ${companyId}`);
      }
    } catch (error) {
      logger.warn('Cache invalidation error:', error.message);
    }
  }

  /**
   * ðŸ“Š ANALYTICS AND MONITORING
   */
  
  async updateUsageAnalytics(qnaId, query, responseTime) {
    try {
      // Update Q&A usage statistics (non-blocking)
      setImmediate(async () => {
        await CompanyKnowledgeQnA.updateOne(
          { _id: qnaId },
          { 
            $inc: { usageCount: 1 },
            $set: { lastUsed: new Date() }
          }
        );
      });
    } catch (error) {
      logger.warn('Analytics update failed:', error.message);
    }
  }

  getPerformanceMetrics() {
    const avgLatency = this.performanceMetrics.searchLatency.length > 0
      ? this.performanceMetrics.searchLatency.reduce((a, b) => a + b, 0) / this.performanceMetrics.searchLatency.length
      : 0;

    const cacheHitRate = this.performanceMetrics.totalQueries > 0
      ? (this.performanceMetrics.cacheHits / this.performanceMetrics.totalQueries) * 100
      : 0;

    return {
      totalQueries: this.performanceMetrics.totalQueries,
      cacheHitRate: Math.round(cacheHitRate * 100) / 100,
      avgLatency: Math.round(avgLatency * 100) / 100,
      cacheHits: this.performanceMetrics.cacheHits,
      cacheMisses: this.performanceMetrics.cacheMisses
    };
  }

  /**
   * ðŸ› ï¸ UTILITY METHODS
   */
  
  countKeywordMatches(resultKeywords, queryKeywords) {
    const matches = resultKeywords.filter(rk => 
      queryKeywords.some(qk => 
        rk.includes(qk) || qk.includes(rk) || 
        this.calculateStringSimilarity(rk, qk) > 0.8
      )
    );
    
    return matches.length / Math.max(queryKeywords.length, 1);
  }

  calculateStringSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = this.levenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }

  // Phonetic similarity (Metaphone Jaccard)
  phoneticSimilarity(a, b) {
    try {
      const tok = (s) => (s || '')
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .split(/\s+/)
        .filter(Boolean);
      // V2 SYSTEM: Simple string matching instead of metaphone
      const meta = (w) => w.toLowerCase().trim();
      const setA = new Set(tok(a).map(meta));
      const setB = new Set(tok(b).map(meta));
      if (setA.size === 0 || setB.size === 0) return 0;
      let inter = 0;
      setA.forEach(v => { if (setB.has(v)) inter++; });
      const union = setA.size + setB.size - inter;
      return union === 0 ? 0 : inter / union;
    } catch (e) {
      return 0;
    }
  }

  // Build/load per-company phonetic dictionary and cache in Redis
  async getCompanyPhoneticDictionary(companyId) {
    const cacheKey = `company:${companyId}:phonetic:dict:v1`;
    if (redisClient) {
      try {
        const cached = await redisClient.get(cacheKey);
        if (cached) return JSON.parse(cached);
      } catch (_) {}
    }

    // Derive dictionary from existing active Q&A keywords and trade terms
      const activeQnas = await CompanyKnowledgeQnA.find({ companyId, status: 'active' })
      .select('keywords tradeCategories')
      .limit(200)
      .lean();
    // V2 DELETED: Legacy natural Metaphone - using V2 keyword matching
    // const metaphone = natural.Metaphone;
    const dict = {};
    activeQnas.forEach(q => {
      (q.keywords || []).forEach(kw => {
        // V2 SYSTEM: Simple lowercase key instead of metaphone
        const key = (kw || '').toLowerCase().trim();
        if (!key) return;
        if (!dict[key]) dict[key] = [];
        if (!dict[key].includes(kw)) dict[key].push(kw);
      });
      // Include trade category labels as anchors
      (q.tradeCategories || []).forEach(tc => {
        // V2 SYSTEM: Simple lowercase key instead of metaphone
        const key = (tc || '').toLowerCase().trim();
        if (!key) return;
        if (!dict[key]) dict[key] = [];
        if (!dict[key].includes(tc)) dict[key].push(tc);
      });
    });

    if (redisClient) {
      try { await redisClient.setex(cacheKey, 3600, JSON.stringify(dict)); } catch (_) {}
    }
    return dict;
  }

  levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  /**
   * ðŸ”§ HEALTH CHECK
   */
  async healthCheck() {
    const health = {
      service: 'CompanyKnowledgeService',
      status: 'healthy',
      mongodb: 'unknown',
      redis: 'unknown',
      performance: this.getPerformanceMetrics(),
      timestamp: new Date()
    };

    try {
      // Test MongoDB
      await CompanyKnowledgeQnA.findOne().limit(1);
      health.mongodb = 'healthy';
    } catch (error) {
      health.mongodb = 'unhealthy';
      health.status = 'degraded';
    }

    try {
      // Test Redis
      if (redisClient) {
        await redisClient.ping();
        health.redis = 'healthy';
      } else {
        health.redis = 'disabled';
      }
    } catch (error) {
      health.redis = 'unhealthy';
    }

    return health;
  }
}

module.exports = CompanyKnowledgeService;
