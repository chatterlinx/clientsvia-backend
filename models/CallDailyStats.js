/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CALL DAILY STATS MODEL (Pre-Computed Analytics)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Part of: Call Center Module V2
 * Created: December 1, 2025
 * Proposal: PROPOSAL-CALL-CENTER-MODULE-V2.md
 * 
 * PURPOSE:
 * ─────────────────────────────────────────────────────────────────────────────
 * Pre-computed daily statistics for instant analytics dashboards.
 * Generated by nightly rollup job (dailyStatsRollup).
 * 
 * WHY PRE-COMPUTED:
 * ─────────────────────────────────────────────────────────────────────────────
 * V1: On-the-fly aggregation on 500K calls = 30+ second queries
 * V2: Read from 7 pre-computed documents = < 10ms
 * 
 * WORKFLOW:
 * ─────────────────────────────────────────────────────────────────────────────
 * 1. dailyStatsRollup job runs every night at 2 AM
 * 2. Aggregates CallSummary data for the previous day
 * 3. Creates/updates CallDailyStats document for that date
 * 4. Dashboard reads from this collection (instant)
 * 
 * RETENTION:
 * ─────────────────────────────────────────────────────────────────────────────
 * Stats are kept forever (they're tiny, ~1KB per day per company).
 * 365 days of data = 365KB per company = negligible.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 */

const mongoose = require('mongoose');
const logger = require('../utils/logger');

// ═══════════════════════════════════════════════════════════════════════════
// SCHEMA DEFINITION
// ═══════════════════════════════════════════════════════════════════════════

const CallDailyStatsSchema = new mongoose.Schema({
  
  // ─────────────────────────────────────────────────────────────────────────
  // IDENTITY (Unique per company per day)
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Company these stats belong to
   */
  companyId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'v2Company', 
    required: [true, 'companyId is required'],
    index: true 
  },
  
  /**
   * Date for these stats (YYYY-MM-DD format)
   * Stored as string for easy querying and uniqueness
   */
  date: { 
    type: String, 
    required: [true, 'date is required'],
    match: [/^\d{4}-\d{2}-\d{2}$/, 'date must be in YYYY-MM-DD format']
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // CALL COUNTS
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Total calls this day
   */
  totalCalls: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Inbound calls
   */
  inboundCalls: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Outbound calls
   */
  outboundCalls: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // OUTCOMES
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Calls completed successfully
   */
  completed: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls transferred to human/external
   */
  transferred: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls that went to voicemail
   */
  voicemail: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls where caller hung up
   */
  abandoned: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls identified as spam
   */
  spam: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls with errors
   */
  errorCount: {
    type: Number,
    default: 0,
    min: 0
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // ROUTING TIERS
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Calls handled by Tier 1 (rule-based, free)
   */
  tier1: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls handled by Tier 2 (semantic, free)
   */
  tier2: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Calls handled by Tier 3 (LLM fallback, paid)
   */
  tier3: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // APPOINTMENTS
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Appointments booked this day
   */
  appointmentsBooked: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Booking rate (appointmentsBooked / totalCalls)
   * Pre-computed for dashboard display
   */
  bookingRate: { 
    type: Number, 
    default: 0,
    min: 0,
    max: 1
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // DURATIONS
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Total call duration in seconds
   */
  totalDurationSeconds: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Average call duration in seconds
   */
  avgDurationSeconds: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Shortest call duration
   */
  minDurationSeconds: {
    type: Number,
    default: 0,
    min: 0
  },
  
  /**
   * Longest call duration
   */
  maxDurationSeconds: {
    type: Number,
    default: 0,
    min: 0
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // INTENTS (Top 20)
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Intent distribution { "BOOK_APPOINTMENT": 34, "SERVICE_QUESTION": 22 }
   * Limited to top 20 intents to keep document small
   */
  intents: {
    type: Map,
    of: Number,
    default: new Map()
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // CUSTOMERS
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * New customers (first-time callers)
   */
  newCustomers: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Returning customers
   */
  returningCustomers: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Unique phone numbers that called
   */
  uniqueCallers: {
    type: Number,
    default: 0,
    min: 0
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // LLM COSTS
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Total LLM cost for this day (in dollars)
   */
  llmCostTotal: { 
    type: Number, 
    default: 0,
    min: 0
  },
  
  /**
   * Average LLM cost per Tier 3 call
   */
  avgLlmCostPerCall: {
    type: Number,
    default: 0,
    min: 0
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // HOURLY BREAKDOWN (for peak hours analysis)
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * Calls per hour (0-23)
   */
  hourlyDistribution: {
    type: Map,
    of: Number,
    default: new Map()
  },
  
  // ─────────────────────────────────────────────────────────────────────────
  // METADATA
  // ─────────────────────────────────────────────────────────────────────────
  
  /**
   * When these stats were computed
   */
  computedAt: { 
    type: Date, 
    default: Date.now 
  },
  
  /**
   * Is this a partial computation? (day not complete yet)
   */
  isPartial: {
    type: Boolean,
    default: false
  },
  
  /**
   * Version of the rollup algorithm (for migrations)
   */
  version: {
    type: Number,
    default: 1
  }
  
}, { 
  timestamps: true,
  collection: 'call_daily_stats'
});

// Backward compatibility: map legacy "errors" field into errorCount on read
CallDailyStatsSchema.pre('init', function(doc) {
  if (doc && doc.errors !== undefined && doc.errorCount === undefined) {
    doc.errorCount = doc.errors;
  }
});


// ═══════════════════════════════════════════════════════════════════════════
// INDEXES
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Unique per company per day
 */
CallDailyStatsSchema.index(
  { companyId: 1, date: 1 }, 
  { unique: true, name: 'idx_company_date_unique' }
);

/**
 * Quick lookup for date ranges (weekly, monthly views)
 */
CallDailyStatsSchema.index(
  { companyId: 1, date: -1 },
  { name: 'idx_company_date_desc' }
);


// ═══════════════════════════════════════════════════════════════════════════
// STATIC METHODS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Upsert daily stats (used by rollup job)
 * 
 * @param {ObjectId} companyId - Company ID
 * @param {string} date - Date in YYYY-MM-DD format
 * @param {Object} stats - Stats to save
 * @returns {Promise<CallDailyStats>}
 */
CallDailyStatsSchema.statics.upsertStats = async function(companyId, date, stats) {
  const doc = await this.findOneAndUpdate(
    { companyId, date },
    {
      $set: {
        ...stats,
        computedAt: new Date(),
        version: 1
      }
    },
    { upsert: true, new: true }
  );
  
  logger.info('[CALL_DAILY_STATS] Stats upserted', {
    companyId: companyId.toString(),
    date,
    totalCalls: stats.totalCalls
  });
  
  return doc;
};

/**
 * Get stats for a date range
 * 
 * @param {ObjectId} companyId - Company ID
 * @param {string} startDate - Start date (YYYY-MM-DD)
 * @param {string} endDate - End date (YYYY-MM-DD)
 * @returns {Promise<CallDailyStats[]>}
 */
CallDailyStatsSchema.statics.getRange = async function(companyId, startDate, endDate) {
  return this.find({
    companyId,
    date: { $gte: startDate, $lte: endDate }
  })
    .sort({ date: -1 })
    .lean();
};

/**
 * Get aggregated stats for a period
 * 
 * @param {ObjectId} companyId - Company ID
 * @param {string} startDate - Start date (YYYY-MM-DD)
 * @param {string} endDate - End date (YYYY-MM-DD)
 * @returns {Promise<Object>}
 */
CallDailyStatsSchema.statics.getAggregatedStats = async function(companyId, startDate, endDate) {
  const stats = await this.aggregate([
    {
      $match: {
        companyId: new mongoose.Types.ObjectId(companyId),
        date: { $gte: startDate, $lte: endDate }
      }
    },
    {
      $group: {
        _id: null,
        totalCalls: { $sum: '$totalCalls' },
        totalDurationSeconds: { $sum: '$totalDurationSeconds' },
        completed: { $sum: '$completed' },
        transferred: { $sum: '$transferred' },
        voicemail: { $sum: '$voicemail' },
        abandoned: { $sum: '$abandoned' },
        spam: { $sum: '$spam' },
        tier1: { $sum: '$tier1' },
        tier2: { $sum: '$tier2' },
        tier3: { $sum: '$tier3' },
        appointmentsBooked: { $sum: '$appointmentsBooked' },
        newCustomers: { $sum: '$newCustomers' },
        returningCustomers: { $sum: '$returningCustomers' },
        llmCostTotal: { $sum: '$llmCostTotal' },
        daysCount: { $sum: 1 }
      }
    }
  ]);
  
  if (stats.length === 0) {
    return {
      totalCalls: 0,
      avgDurationSeconds: 0,
      completed: 0,
      transferred: 0,
      voicemail: 0,
      abandoned: 0,
      spam: 0,
      tier1: 0,
      tier2: 0,
      tier3: 0,
      appointmentsBooked: 0,
      bookingRate: 0,
      newCustomers: 0,
      returningCustomers: 0,
      llmCostTotal: 0
    };
  }
  
  const result = stats[0];
  result.avgDurationSeconds = result.totalCalls > 0 
    ? Math.round(result.totalDurationSeconds / result.totalCalls) 
    : 0;
  result.bookingRate = result.totalCalls > 0 
    ? result.appointmentsBooked / result.totalCalls 
    : 0;
  
  delete result._id;
  delete result.daysCount;
  
  return result;
};

/**
 * Get stats for today (may be partial)
 * 
 * @param {ObjectId} companyId - Company ID
 * @returns {Promise<CallDailyStats|null>}
 */
CallDailyStatsSchema.statics.getToday = async function(companyId) {
  const today = new Date().toISOString().split('T')[0];
  return this.findOne({ companyId, date: today }).lean();
};

/**
 * Get last N days of stats
 * 
 * @param {ObjectId} companyId - Company ID
 * @param {number} days - Number of days
 * @returns {Promise<CallDailyStats[]>}
 */
CallDailyStatsSchema.statics.getLastNDays = async function(companyId, days) {
  const dates = [];
  for (let i = 0; i < days; i++) {
    const d = new Date();
    d.setDate(d.getDate() - i);
    dates.push(d.toISOString().split('T')[0]);
  }
  
  return this.find({
    companyId,
    date: { $in: dates }
  })
    .sort({ date: -1 })
    .lean();
};

/**
 * Check if stats exist for a date
 * 
 * @param {ObjectId} companyId - Company ID
 * @param {string} date - Date in YYYY-MM-DD format
 * @returns {Promise<boolean>}
 */
CallDailyStatsSchema.statics.existsForDate = async function(companyId, date) {
  const count = await this.countDocuments({ companyId, date });
  return count > 0;
};

/**
 * Get companies that need stats rolled up for a date
 * (Have calls but no stats yet)
 * 
 * @param {string} date - Date in YYYY-MM-DD format
 * @returns {Promise<ObjectId[]>}
 */
CallDailyStatsSchema.statics.getCompaniesNeedingRollup = async function(date) {
  const CallSummary = mongoose.model('CallSummary');
  
  // Find companies with calls on this date
  const startOfDay = new Date(date);
  const endOfDay = new Date(date);
  endOfDay.setDate(endOfDay.getDate() + 1);
  
  const companiesWithCalls = await CallSummary.distinct('companyId', {
    startedAt: { $gte: startOfDay, $lt: endOfDay }
  });
  
  // Find companies that already have stats
  const companiesWithStats = await this.distinct('companyId', { date });
  
  // Return companies that need rollup
  const companiesWithStatsSet = new Set(companiesWithStats.map(id => id.toString()));
  return companiesWithCalls.filter(id => !companiesWithStatsSet.has(id.toString()));
};


// ═══════════════════════════════════════════════════════════════════════════
// MODEL EXPORT
// ═══════════════════════════════════════════════════════════════════════════

const CallDailyStats = mongoose.model('CallDailyStats', CallDailyStatsSchema);

module.exports = CallDailyStats;

