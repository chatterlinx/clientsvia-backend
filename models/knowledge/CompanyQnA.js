/**
 * Company Q&A Model with AI-Powered Keyword Generation
 * Enterprise-grade knowledge base with automatic keyword extraction
 * 
 * ðŸ¤– AI AGENT ROUTING REFERENCE:
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘ PRIORITY #1 KNOWLEDGE SOURCE - COMPANY Q&A ROUTING FLOW         â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘ 1. Customer question received by AI agent                       â•‘
 * â•‘ 2. AI checks Company Q&A FIRST (highest priority)               â•‘
 * â•‘ 3. CompanyKnowledgeService.findAnswerForAIAgent() called        â•‘
 * â•‘ 4. This model queried via Mongoose with semantic search         â•‘
 * â•‘ 5. Auto-generated keywords matched for relevance scoring        â•‘
 * â•‘ 6. Redis cache used for performance optimization                â•‘
 * â•‘ 7. If confidence >= threshold â†’ Return company-specific answer  â•‘
 * â•‘ 8. If confidence < threshold â†’ Fall to Priority #2 (Trade Q&A)  â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ðŸ”— Integration Points:
 * â€¢ Model: /models/knowledge/CompanyQnA.js (THIS FILE)
 * â€¢ Service: /services/knowledge/CompanyKnowledgeService.js
 * â€¢ API Route: /routes/knowledge/companyKnowledge.js
 * â€¢ AI Route: /routes/aiAgentLogic.js â†’ /api/ai-agent/company-knowledge/:companyId
 * â€¢ Frontend: /public/js/components/CompanyQnAManager.js
 * â€¢ Cache: Redis keys â†’ knowledge:company:{companyId}:*
 */

const mongoose = require('mongoose');
const { ObjectId } = mongoose.Schema.Types;

// Advanced keyword generation service
const KeywordGenerationService = require('../../services/knowledge/KeywordGenerationService');

const companyQnASchema = new mongoose.Schema({
  // Core Q&A Content
  question: {
    type: String,
    required: true,
    trim: true,
    maxLength: 500,
    index: 'text' // Full-text search index
  },
  
  answer: {
    type: String,
    required: true,
    trim: true,
    maxLength: 2000,
    index: 'text' // Full-text search index
  },
  
  // Company Association
  companyId: {
    type: ObjectId,
    ref: 'Company',
    required: true,
    index: true // Critical for fast company-specific queries
  },
  
  // AI-Generated Keywords (Automatic)
  keywords: [{
    type: String,
    lowercase: true,
    trim: true,
    index: true // Fast keyword matching
  }],
  
  // Enhanced Keyword Categories
  keywordCategories: {
    entities: [String], // Named entities (brands, products, locations)
    technical: [String], // Technical terms specific to trade
    intent: [String], // User intent keywords (repair, install, price)
    semantic: [String], // Semantic variations and synonyms
    custom: [String] // Manually added keywords
  },
  
  // Performance & Analytics
  confidence: {
    type: Number,
    default: 0.8,
    min: 0,
    max: 1,
    index: true // For confidence-based filtering
  },
  
  searchScore: {
    type: Number,
    default: 0,
    index: true // For popularity-based ranking
  },
  
  usageCount: {
    type: Number,
    default: 0,
    index: true // Track Q&A effectiveness
  },
  
  lastUsed: {
    type: Date,
    index: true // For cache warming strategies
  },
  
  // Content Classification
  category: {
    type: String,
    enum: [
      'general', 'pricing', 'services', 'policies', 
      'technical', 'emergency', 'scheduling', 'warranty'
    ],
    default: 'general',
    index: true
  },
  
  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'critical'],
    default: 'normal',
    index: true
  },
  
  // Trade-Specific Context
  tradeCategories: [{
    type: String,
    index: true // Multi-trade support
  }],
  
  // Content Management
  status: {
    type: String,
    enum: ['draft', 'active', 'archived', 'under_review'],
    default: 'active',
    index: true
  },
  
  tags: [{
    type: String,
    lowercase: true,
    trim: true
  }],
  
  // Metadata
  createdBy: {
    type: ObjectId,
    ref: 'User'
  },
  
  lastModifiedBy: {
    type: ObjectId,
    ref: 'User'
  },
  
  // AI Enhancement Tracking
  keywordGenerationVersion: {
    type: String,
    default: '1.0'
  },
  
  autoGenerated: {
    type: Boolean,
    default: false
  },
  
  needsReview: {
    type: Boolean,
    default: false
  }
  
}, {
  timestamps: true, // Automatic createdAt and updatedAt
  
  // Optimized indexes for fast queries
  indexes: [
    // Compound indexes for common query patterns
    { companyId: 1, status: 1, priority: -1 },
    { companyId: 1, keywords: 1, confidence: -1 },
    { companyId: 1, category: 1, usageCount: -1 },
    { companyId: 1, tradeCategories: 1, searchScore: -1 },
    
    // Text search index for full-text queries
    { question: 'text', answer: 'text', keywords: 'text' },
    
    // Performance indexes
    { lastUsed: -1 }, // For cache warming
    { usageCount: -1 }, // For popularity ranking
    { confidence: -1 } // For quality filtering
  ]
});

// ðŸš€ WORLD-CLASS KEYWORD GENERATION MIDDLEWARE
// ðŸ¤– AI ROUTING: This middleware auto-generates keywords for semantic search
// Called on: Q&A save/update â†’ KeywordGenerationService â†’ AI agent matching
companyQnASchema.pre('save', async function(next) {
  try {
    // Only generate keywords if question or answer changed
    if (this.isModified('question') || this.isModified('answer') || this.isNew) {
      
      console.log('ðŸ§  CHECKPOINT: Starting keyword generation for Q&A:', this.question.substring(0, 50) + '...');
      
      // Ensure required fields have defaults to prevent validation errors
      if (!this.keywords) this.keywords = [];
      if (!this.keywordCategories) {
        this.keywordCategories = {
          entities: [],
          technical: [],
          intent: [],
          semantic: [],
          custom: []
        };
      }
      
      try {
        // Get company context for enhanced keyword generation
        const company = await mongoose.model('Company').findById(this.companyId)
          .select('tradeCategories companyName businessType');
        
        const context = {
          tradeCategories: company?.tradeCategories || this.tradeCategories || [],
          companyName: '', // Don't include company name in keyword generation
          businessType: company?.businessType
        };
        
        console.log('ðŸ§  CHECKPOINT: Company context loaded for keyword generation');
        
        // Generate comprehensive keywords
        const keywordService = new KeywordGenerationService();
        const generatedKeywords = await keywordService.generateAdvancedKeywords(
          this.question,
          this.answer,
          context
        );
        
        console.log('ðŸ§  CHECKPOINT: Keywords generated successfully');
        
        // Update keyword fields
        this.keywords = generatedKeywords.primary || [];
        this.keywordCategories = {
          entities: generatedKeywords.entities || [],
          technical: generatedKeywords.technical || [],
          intent: generatedKeywords.intent || [],
          semantic: generatedKeywords.semantic || [],
          custom: this.keywordCategories?.custom || []
        };
        
        // Auto-categorize content
        this.category = keywordService.detectCategory(this.question, this.answer) || 'general';
        this.priority = keywordService.detectPriority(this.question, this.answer) || 'normal';
        
        // Update metadata
        this.keywordGenerationVersion = keywordService.getVersion();
        this.autoGenerated = true;
        
        console.log('âœ… CHECKPOINT: Generated keywords:', generatedKeywords.primary?.slice(0, 5) || []);
        
      } catch (keywordError) {
        console.error('âŒ CHECKPOINT: Keyword generation service failed:', keywordError);
        
        // Fallback: Generate basic keywords manually to prevent save failure
        const basicKeywords = this.generateFallbackKeywords(this.question, this.answer);
        this.keywords = basicKeywords;
        this.category = this.category || 'general';
        this.priority = this.priority || 'normal';
        this.autoGenerated = false;
        
        console.log('âœ… CHECKPOINT: Using fallback keywords:', basicKeywords.slice(0, 5));
      }
    }
    
    console.log('âœ… CHECKPOINT: Pre-save middleware completed successfully');
    next();
    
  } catch (error) {
    console.error('âŒ CRITICAL: Pre-save middleware failed completely:', error);
    console.error('âŒ CHECKPOINT: This will cause 500 error on Q&A save');
    
    // Set minimal defaults to prevent validation errors
    this.keywords = this.keywords || [];
    this.category = this.category || 'general';
    this.priority = this.priority || 'normal';
    this.keywordCategories = this.keywordCategories || {
      entities: [], technical: [], intent: [], semantic: [], custom: []
    };
    
    // Continue with save despite keyword generation failure
    next();
  }
});

// Fallback keyword generation method
companyQnASchema.methods.generateFallbackKeywords = function(question, answer) {
  try {
    const text = `${question} ${answer}`.toLowerCase();
    const words = text.split(/\s+/)
      .filter(word => word.length > 3)
      .filter(word => !['what', 'when', 'where', 'why', 'how', 'the', 'and', 'for', 'with', 'this', 'that'].includes(word))
      .slice(0, 10);
    
    return [...new Set(words)]; // Remove duplicates
  } catch (error) {
    console.error('âŒ Even fallback keyword generation failed:', error);
    return ['general', 'question'];
  }
};

// ðŸŽ¯ PERFORMANCE TRACKING MIDDLEWARE
companyQnASchema.post('findOne', function(doc) {
  if (doc) {
    // Asynchronously update usage stats (don't block response)
    setImmediate(async () => {
      try {
        await mongoose.model('CompanyQnA').updateOne(
          { _id: doc._id },
          { 
            $inc: { usageCount: 1 },
            $set: { lastUsed: new Date() }
          }
        );
      } catch (error) {
        console.error('Failed to update usage stats:', error);
      }
    });
  }
});

// ðŸ” ADVANCED SEARCH METHODS
companyQnASchema.statics.searchByKeywords = async function(keywords, companyId, options = {}) {
  const {
    limit = 10,
    minConfidence = 0.7,
    categories = [],
    tradeCategories = []
  } = options;
  
  const query = {
    companyId,
    status: 'active',
    confidence: { $gte: minConfidence }
  };
  
  // Add keyword matching
  if (keywords && keywords.length > 0) {
    query.keywords = { $in: keywords.map(k => k.toLowerCase()) };
  }
  
  // Add category filters
  if (categories.length > 0) {
    query.category = { $in: categories };
  }
  
  if (tradeCategories.length > 0) {
    query.tradeCategories = { $in: tradeCategories };
  }
  
  return this.find(query)
    .sort({ searchScore: -1, confidence: -1, usageCount: -1 })
    .limit(limit)
    .lean(); // Fast queries without Mongoose overhead
};

// ðŸŽ¯ FUZZY SEARCH METHOD
companyQnASchema.statics.fuzzySearch = async function(searchText, companyId, options = {}) {
  const { limit = 5, minScore = 0.5 } = options;
  
  return this.find({
    companyId,
    status: 'active',
    $text: { $search: searchText }
  }, {
    score: { $meta: 'textScore' }
  })
  .sort({ score: { $meta: 'textScore' }, usageCount: -1 })
  .limit(limit)
  .lean();
};

// ðŸš€ BULK KEYWORD REGENERATION
companyQnASchema.statics.regenerateAllKeywords = async function(companyId) {
  const qnas = await this.find({ companyId, status: 'active' });
  const keywordService = new KeywordGenerationService();
  
  const results = {
    processed: 0,
    success: 0,
    errors: 0
  };
  
  for (const qna of qnas) {
    try {
      results.processed++;
      
      // Force keyword regeneration
      qna.markModified('question');
      await qna.save();
      
      results.success++;
    } catch (error) {
      console.error(`Failed to regenerate keywords for Q&A ${qna._id}:`, error);
      results.errors++;
    }
  }
  
  return results;
};

// V2 FIX: Use different model name to prevent conflict with /models/CompanyQnA.js
// Export with explicit collection name to match production 'companyqnas' collection  
module.exports = mongoose.models.CompanyKnowledgeQnA || mongoose.model('CompanyKnowledgeQnA', companyQnASchema, 'companyqnas');
