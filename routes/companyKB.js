const express = require('express');
const router = express.Router();
const Company = require('../models/Company');
const { generateKeywords, suggestIntent } = require('../utils/keywordGenerator');

/**
 * ========================================= 
 * COMPANY KNOWLEDGE BASE API ROUTES
 * Priority #1 knowledge source for company-specific rules
 * ========================================= 
 */

// Get all company Q&As for a specific company
router.get('/companies/:companyId/company-kb', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { intent, search } = req.query;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        let companyKB = company.companyKB || [];

        // Filter by intent if specified
        if (intent) {
            companyKB = companyKB.filter(qa => qa.intent && qa.intent.startsWith(intent));
        }

        // Search functionality
        if (search) {
            const searchLower = search.toLowerCase();
            companyKB = companyKB.filter(qa => 
                qa.question?.toLowerCase().includes(searchLower) ||
                qa.answer?.toLowerCase().includes(searchLower) ||
                qa.keywords?.some(keyword => keyword.toLowerCase().includes(searchLower))
            );
        }

        res.json({
            success: true,
            data: companyKB,
            meta: {
                total: companyKB.length,
                companyId,
                filters: { intent, search }
            }
        });

    } catch (error) {
        console.error('Error fetching company KB:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Add new company Q&A entry
router.post('/companies/:companyId/company-kb', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { question, answer, keywords, intent, negativeKeywords, validThrough, reviewEveryDays } = req.body;

        if (!question || !answer) {
            return res.status(400).json({ success: false, message: 'Question and answer are required' });
        }

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        if (!company.companyKB) {
            company.companyKB = [];
        }

        // Auto-generate keywords if not provided or enhance existing ones
        const keywordGeneration = generateKeywords(question, answer, keywords);
        const autoIntent = intent || suggestIntent(question, answer);

        // Generate unique ID for the Q&A entry
        const newQnA = {
            id: `company-qa-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            source: 'company_kb',
            companyID: companyId,
            question: question.trim(),
            answer: answer.trim(),
            keywords: keywordGeneration.keywords,
            negativeKeywords: negativeKeywords || keywordGeneration.suggestedNegativeKeywords,
            intent: autoIntent,
            validThrough: validThrough || null,
            reviewEveryDays: reviewEveryDays || 180,
            version: 1,
            isActive: true,
            metadata: {
                createdAt: new Date(),
                createdBy: 'admin', // TODO: Get from auth
                updatedAt: new Date(),
                lastReviewed: new Date(),
                keywordConfidence: keywordGeneration.confidence,
                autoGenerated: !keywords || keywords.length === 0, // Track if keywords were auto-generated
                usage: {
                    timesMatched: 0,
                    lastMatched: null,
                    averageConfidence: 0
                }
            }
        };

        company.companyKB.push(newQnA);
        
        // Update company KB metadata
        if (!company.companyKBSettings) {
            company.companyKBSettings = {
                version: '1.0.0',
                lastUpdated: new Date(),
                autoPublish: 'manual',
                reviewFrequency: 180,
                confidenceThreshold: 0.80
            };
        } else {
            company.companyKBSettings.lastUpdated = new Date();
            // Increment version - safely handle version string
            const currentVersion = company.companyKBSettings.version || '1.0.0';
            if (typeof currentVersion === 'string' && currentVersion.includes('.')) {
                const versionParts = currentVersion.split('.');
                versionParts[2] = (parseInt(versionParts[2]) + 1).toString();
                company.companyKBSettings.version = versionParts.join('.');
            } else {
                company.companyKBSettings.version = '1.0.1';
            }
        }

        await company.save();

        res.json({
            success: true,
            data: newQnA,
            message: 'Company Q&A added successfully'
        });

    } catch (error) {
        console.error('Error adding company Q&A:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Update company Q&A entry
router.put('/companies/:companyId/company-kb/:qaId', async (req, res) => {
    try {
        const { companyId, qaId } = req.params;
        const { question, answer, keywords, intent, negativeKeywords, validThrough, reviewEveryDays, isActive } = req.body;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const qaIndex = company.companyKB?.findIndex(qa => qa.id === qaId);
        if (qaIndex === -1) {
            return res.status(404).json({ success: false, message: 'Q&A entry not found' });
        }

        // Update the Q&A entry
        const updatedQnA = {
            ...company.companyKB[qaIndex],
            question: question?.trim() || company.companyKB[qaIndex].question,
            answer: answer?.trim() || company.companyKB[qaIndex].answer,
            keywords: keywords || company.companyKB[qaIndex].keywords,
            negativeKeywords: negativeKeywords || company.companyKB[qaIndex].negativeKeywords,
            intent: intent || company.companyKB[qaIndex].intent,
            validThrough: validThrough || company.companyKB[qaIndex].validThrough,
            reviewEveryDays: reviewEveryDays || company.companyKB[qaIndex].reviewEveryDays,
            isActive: isActive !== undefined ? isActive : company.companyKB[qaIndex].isActive,
            metadata: {
                ...company.companyKB[qaIndex].metadata,
                updatedAt: new Date(),
                lastReviewed: new Date()
            }
        };

        company.companyKB[qaIndex] = updatedQnA;

        // Update company KB metadata
        if (company.companyKBSettings) {
            company.companyKBSettings.lastUpdated = new Date();
        }

        await company.save();

        res.json({
            success: true,
            data: updatedQnA,
            message: 'Company Q&A updated successfully'
        });

    } catch (error) {
        console.error('Error updating company Q&A:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Delete company Q&A entry
router.delete('/companies/:companyId/company-kb/:qaId', async (req, res) => {
    try {
        const { companyId, qaId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const qaIndex = company.companyKB?.findIndex(qa => qa.id === qaId);
        if (qaIndex === -1) {
            return res.status(404).json({ success: false, message: 'Q&A entry not found' });
        }

        company.companyKB.splice(qaIndex, 1);

        // Update company KB metadata
        if (company.companyKBSettings) {
            company.companyKBSettings.lastUpdated = new Date();
        }

        await company.save();

        res.json({
            success: true,
            message: 'Company Q&A deleted successfully'
        });

    } catch (error) {
        console.error('Error deleting company Q&A:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Get/Update company KB settings
router.get('/companies/:companyId/company-kb-settings', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const settings = company.companyKBSettings || {
            version: '1.0.0',
            lastUpdated: new Date(),
            autoPublish: 'manual',
            reviewFrequency: 180,
            confidenceThreshold: 0.80,
            entryCount: 0
        };

        // Update entry count
        settings.entryCount = company.companyKB?.length || 0;

        res.json({
            success: true,
            data: settings
        });

    } catch (error) {
        console.error('Error fetching company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

router.post('/companies/:companyId/company-kb-settings', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { autoPublish, reviewFrequency, confidenceThreshold } = req.body;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        company.companyKBSettings = {
            ...company.companyKBSettings,
            autoPublish: autoPublish || 'manual',
            reviewFrequency: reviewFrequency || 180,
            confidenceThreshold: confidenceThreshold || 0.80,
            lastUpdated: new Date()
        };

        await company.save();

        res.json({
            success: true,
            data: company.companyKBSettings,
            message: 'Company KB settings updated successfully'
        });

    } catch (error) {
        console.error('Error updating company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// PUT endpoint for company KB settings (alternative route for frontend compatibility)
router.put('/companies/:companyId/settings', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { autoPublish, reviewFrequency, confidenceThreshold } = req.body;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        // Initialize companyKBSettings with proper schema defaults if it doesn't exist
        if (!company.companyKBSettings) {
            company.companyKBSettings = {
                enabled: true,
                autoPublish: false,
                requireApproval: true,
                maxQuestions: 100,
                confidenceThreshold: 0.80,
                fuzzyMatchEnabled: true,
                fuzzyMatchThreshold: 0.85,
                priorityWeights: {
                    high: 1.0,
                    normal: 0.8,
                    low: 0.6
                },
                autoSuggestFromTradeKB: true,
                versionHistory: {
                    enabled: true,
                    maxVersions: 10,
                    autoCleanup: true
                },
                analytics: {
                    trackUsage: true,
                    trackPerformance: true,
                    generateReports: true
                },
                lastPublished: null,
                publishedBy: null,
                publishVersion: 0
            };
        }

        // Ensure nested objects exist with defaults
        if (!company.companyKBSettings.priorityWeights) {
            company.companyKBSettings.priorityWeights = {
                high: 1.0,
                normal: 0.8,
                low: 0.6
            };
        }

        if (!company.companyKBSettings.versionHistory) {
            company.companyKBSettings.versionHistory = {
                enabled: true,
                maxVersions: 10,
                autoCleanup: true
            };
        }

        if (!company.companyKBSettings.analytics) {
            company.companyKBSettings.analytics = {
                trackUsage: true,
                trackPerformance: true,
                generateReports: true
            };
        }

        // Update only the settings provided in the request
        if (autoPublish !== undefined) {
            company.companyKBSettings.autoPublish = autoPublish;
        }
        if (reviewFrequency !== undefined) {
            company.companyKBSettings.reviewFrequency = reviewFrequency;
        }
        if (confidenceThreshold !== undefined) {
            company.companyKBSettings.confidenceThreshold = confidenceThreshold;
        }

        // Use findByIdAndUpdate to only update companyKBSettings field to avoid other validation issues
        const updatedCompany = await Company.findByIdAndUpdate(
            companyId,
            { $set: { companyKBSettings: company.companyKBSettings } },
            { new: true, runValidators: false } // Skip validators to avoid other field issues
        );

        res.json({
            success: true,
            data: updatedCompany.companyKBSettings,
            message: 'Company KB settings updated successfully'
        });

    } catch (error) {
        console.error('Error updating company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// GET endpoint for company KB settings (alternative route for frontend compatibility)
router.get('/companies/:companyId/settings', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        // Ensure we have a complete settings object with proper defaults
        const defaultSettings = {
            enabled: true,
            autoPublish: false,
            requireApproval: true,
            maxQuestions: 100,
            confidenceThreshold: 0.80,
            fuzzyMatchEnabled: true,
            fuzzyMatchThreshold: 0.85,
            priorityWeights: {
                high: 1.0,
                normal: 0.8,
                low: 0.6
            },
            autoSuggestFromTradeKB: true,
            versionHistory: {
                enabled: true,
                maxVersions: 10,
                autoCleanup: true
            },
            analytics: {
                trackUsage: true,
                trackPerformance: true,
                generateReports: true
            },
            lastPublished: null,
            publishedBy: null,
            publishVersion: 0,
            entryCount: company.companyKB?.length || 0
        };

        // Merge existing settings with defaults
        const settings = company.companyKBSettings ? 
            { ...defaultSettings, ...company.companyKBSettings.toObject() } : 
            defaultSettings;

        // Ensure entry count is current
        settings.entryCount = company.companyKB?.length || 0;

        res.json({
            success: true,
            data: settings
        });

    } catch (error) {
        console.error('Error fetching company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Publish company KB (make it live)
router.post('/companies/:companyId/company-kb/publish', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        // Update publish timestamp
        if (!company.companyKBSettings) {
            company.companyKBSettings = {};
        }

        company.companyKBSettings.lastPublished = new Date();
        company.companyKBSettings.publishedEntryCount = company.companyKB?.length || 0;

        await company.save();

        res.json({
            success: true,
            message: `Published ${company.companyKB?.length || 0} company Q&A entries`,
            data: {
                publishedAt: company.companyKBSettings.lastPublished,
                entryCount: company.companyKBSettings.publishedEntryCount
            }
        });

    } catch (error) {
        console.error('Error publishing company KB:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Regenerate keywords for existing Company KB entries
router.post('/companies/:companyId/company-kb/:qaId/regenerate-keywords', async (req, res) => {
    try {
        const { companyId, qaId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const qaIndex = company.companyKB?.findIndex(qa => qa.id === qaId);
        if (qaIndex === -1) {
            return res.status(404).json({ success: false, message: 'Q&A entry not found' });
        }

        const qa = company.companyKB[qaIndex];
        
        // Regenerate keywords
        const keywordGeneration = generateKeywords(qa.question, qa.answer, []);
        const newIntent = suggestIntent(qa.question, qa.answer);
        
        // Update the Q&A entry
        company.companyKB[qaIndex] = {
            ...qa,
            keywords: keywordGeneration.keywords,
            negativeKeywords: keywordGeneration.suggestedNegativeKeywords,
            intent: newIntent,
            metadata: {
                ...qa.metadata,
                updatedAt: new Date(),
                keywordConfidence: keywordGeneration.confidence,
                autoGenerated: true
            }
        };

        await company.save();

        res.json({
            success: true,
            data: company.companyKB[qaIndex],
            message: 'Keywords regenerated successfully',
            analysis: {
                keywordsGenerated: keywordGeneration.keywords.length,
                confidence: keywordGeneration.confidence,
                intent: newIntent
            }
        });

    } catch (error) {
        console.error('Error regenerating keywords:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Bulk regenerate keywords for all Company KB entries
router.post('/companies/:companyId/company-kb/bulk-regenerate-keywords', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        if (!company.companyKB || company.companyKB.length === 0) {
            return res.status(400).json({ success: false, message: 'No Q&A entries found' });
        }

        let updatedCount = 0;
        const results = [];

        // Process each Q&A entry
        company.companyKB.forEach((qa, index) => {
            const keywordGeneration = generateKeywords(qa.question, qa.answer, []);
            const newIntent = suggestIntent(qa.question, qa.answer);
            
            company.companyKB[index] = {
                ...qa,
                keywords: keywordGeneration.keywords,
                negativeKeywords: keywordGeneration.suggestedNegativeKeywords,
                intent: newIntent,
                metadata: {
                    ...qa.metadata,
                    updatedAt: new Date(),
                    keywordConfidence: keywordGeneration.confidence,
                    autoGenerated: true
                }
            };

            updatedCount++;
            results.push({
                id: qa.id,
                question: qa.question.substring(0, 50) + '...',
                keywordsGenerated: keywordGeneration.keywords.length,
                confidence: keywordGeneration.confidence,
                intent: newIntent
            });
        });

        await company.save();

        res.json({
            success: true,
            message: `Keywords regenerated for ${updatedCount} Q&A entries`,
            data: {
                updatedCount,
                totalEntries: company.companyKB.length,
                results
            }
        });

    } catch (error) {
        console.error('Error bulk regenerating keywords:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

module.exports = router;
