const express = require('express');
const router = express.Router();
const Company = require('../models/Company');
const { generateKeywords, suggestIntent } = require('../utils/keywordGenerator');
const mongoose = require('mongoose');

/**
 * ========================================= 
 * COMPANY KNOWLEDGE BASE API ROUTES
 * Priority #1 knowledge source for company-specific rules
 * ========================================= 
 */

// Get all company Q&As for a specific company
router.get('/companies/:companyId/company-kb', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { intent, search } = req.query;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        let companyKB = company.companyKB || [];

        // Filter by intent if specified
        if (intent) {
            companyKB = companyKB.filter(qa => qa.intent && qa.intent.startsWith(intent));
        }

        // Search functionality
        if (search) {
            const searchLower = search.toLowerCase();
            companyKB = companyKB.filter(qa => 
                qa.question?.toLowerCase().includes(searchLower) ||
                qa.answer?.toLowerCase().includes(searchLower) ||
                qa.keywords?.some(keyword => keyword.toLowerCase().includes(searchLower))
            );
        }

        res.json({
            success: true,
            data: companyKB,
            meta: {
                total: companyKB.length,
                companyId,
                filters: { intent, search }
            }
        });

    } catch (error) {
        console.error('Error fetching company KB:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Add new company Q&A entry
router.post('/companies/:companyId/company-kb', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { question, answer, category, priority, keywords, intent, negativeKeywords, validThrough, reviewEveryDays } = req.body;

        if (!question || !answer) {
            return res.status(400).json({ success: false, message: 'Question and answer are required' });
        }

        // Check if company exists and add the Q&A entry
        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        // Fix any invalid LLM models before saving (production cleanup)
        if (company.agentIntelligenceSettings) {
            if (company.agentIntelligenceSettings.llmModel && company.agentIntelligenceSettings.llmModel.includes('ollama')) {
                company.agentIntelligenceSettings.llmModel = 'gemini-pro';
            }
            if (company.agentIntelligenceSettings.fallbackModel && company.agentIntelligenceSettings.fallbackModel.includes('ollama')) {
                company.agentIntelligenceSettings.fallbackModel = 'gemini-pro';
            }
        }

        // Auto-generate keywords if not provided or enhance existing ones
        const keywordGeneration = generateKeywords(question, answer, keywords);
        const autoIntent = intent || suggestIntent(question, answer);

        // Generate unique ID for the Q&A entry
        const newQnA = {
            id: `company-qa-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            question: question.trim(),
            answer: answer.trim(),
            category: category || 'general',
            priority: priority || 'normal',
            keywords: keywordGeneration.keywords,
            negativeKeywords: negativeKeywords || keywordGeneration.suggestedNegativeKeywords,
            intent: autoIntent,
            isActive: true,
            version: 1,
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: 'admin', // TODO: Get from auth
            lastReviewed: new Date(),
            usageCount: 0,
            // Store auto-generation info for display
            autoGenerated: !keywords || keywords.length === 0,
            keywordConfidence: keywordGeneration.confidence
        };

        // Initialize companyKB array if it doesn't exist
        if (!company.companyKB) {
            company.companyKB = [];
        }

        // Add the new Q&A entry
        company.companyKB.push(newQnA);

        // Update company KB settings
        if (!company.companyKBSettings) {
            company.companyKBSettings = {
                enabled: true,
                requireApproval: true,
                maxQuestions: 100,
                confidenceThreshold: 0.8,
                fuzzyMatchEnabled: true,
                fuzzyMatchThreshold: 0.85,
                autoSuggestFromTradeKB: true
            };
        }
        
        company.companyKBSettings.lastUpdated = new Date();
        company.companyKBSettings.version = '1.0.1';
        company.companyKBSettings.entryCount = company.companyKB.length;

        // Save the company
        await company.save();
        //     }
        // );

        // if (updateResult.modifiedCount === 0) {
        //     return res.status(404).json({ success: false, message: 'Failed to update company' });
        // }

        // Just test the response for now
        console.log('Testing Q&A creation endpoint...');

        res.json({
            success: true,
            data: newQnA,
            message: 'Company Q&A added successfully'
        });

    } catch (error) {
        console.error('Error adding company Q&A:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Update company Q&A entry
router.put('/companies/:companyId/company-kb/:qaId', async (req, res) => {
    try {
        const { companyId, qaId } = req.params;
        const { question, answer, category, priority, keywords, intent, negativeKeywords, validThrough, reviewEveryDays, isActive } = req.body;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const qaIndex = company.companyKB?.findIndex(qa => qa.id === qaId);
        if (qaIndex === -1) {
            return res.status(404).json({ success: false, message: 'Q&A entry not found' });
        }

        // If question or answer is updated, regenerate keywords
        const existingQA = company.companyKB[qaIndex];
        let updatedKeywords = keywords;
        
        if ((question && question !== existingQA.question) || (answer && answer !== existingQA.answer)) {
            const keywordGeneration = generateKeywords(
                question || existingQA.question, 
                answer || existingQA.answer, 
                keywords
            );
            updatedKeywords = keywordGeneration.keywords;
        }

        // Update the Q&A entry
        const updatedQnA = {
            ...existingQA,
            question: question?.trim() || existingQA.question,
            answer: answer?.trim() || existingQA.answer,
            category: category || existingQA.category,
            priority: priority || existingQA.priority,
            keywords: updatedKeywords || existingQA.keywords,
            negativeKeywords: negativeKeywords || existingQA.negativeKeywords,
            intent: intent || existingQA.intent,
            isActive: isActive !== undefined ? isActive : existingQA.isActive,
            updatedAt: new Date(),
            lastReviewed: new Date(),
            version: (existingQA.version || 1) + 1
        };

        company.companyKB[qaIndex] = updatedQnA;

        // Update company KB metadata
        if (company.companyKBSettings) {
            company.companyKBSettings.lastUpdated = new Date();
        }

        // Use direct update to avoid validation issues
        await Company.findByIdAndUpdate(
            companyId, 
            { 
                companyKB: company.companyKB,
                companyKBSettings: company.companyKBSettings
            }, 
            { runValidators: false }
        );

        res.json({
            success: true,
            data: updatedQnA,
            message: 'Company Q&A updated successfully'
        });

    } catch (error) {
        console.error('Error updating company Q&A:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Delete company Q&A entry
router.delete('/companies/:companyId/company-kb/:qaId', async (req, res) => {
    try {
        const { companyId, qaId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const qaIndex = company.companyKB?.findIndex(qa => qa.id === qaId);
        if (qaIndex === -1) {
            return res.status(404).json({ success: false, message: 'Q&A entry not found' });
        }

        company.companyKB.splice(qaIndex, 1);

        // Update company KB metadata
        if (company.companyKBSettings) {
            company.companyKBSettings.lastUpdated = new Date();
        }

        // Use direct update to avoid validation issues
        await Company.findByIdAndUpdate(
            companyId, 
            { 
                companyKB: company.companyKB,
                companyKBSettings: company.companyKBSettings
            }, 
            { runValidators: false }
        );

        res.json({
            success: true,
            message: 'Company Q&A deleted successfully'
        });

    } catch (error) {
        console.error('Error deleting company Q&A:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Get/Update company KB settings
router.get('/companies/:companyId/company-kb-settings', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const settings = company.companyKBSettings || {
            version: '1.0.0',
            lastUpdated: new Date(),
            reviewFrequency: 180,
            confidenceThreshold: 0.80,
            entryCount: 0
        };

        // Update entry count
        settings.entryCount = company.companyKB?.length || 0;

        res.json({
            success: true,
            data: settings
        });

    } catch (error) {
        console.error('Error fetching company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

router.post('/companies/:companyId/company-kb-settings', async (req, res) => {
    try {
        const { companyId } = req.params;
        const { reviewFrequency, confidenceThreshold } = req.body;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        company.companyKBSettings = {
            ...company.companyKBSettings,
            reviewFrequency: reviewFrequency || 180,
            confidenceThreshold: confidenceThreshold || 0.80,
            lastUpdated: new Date()
        };

        await company.save();

        res.json({
            success: true,
            data: company.companyKBSettings,
            message: 'Company KB settings updated successfully'
        });

    } catch (error) {
        console.error('Error updating company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// PUT endpoint for company KB settings (alternative route for frontend compatibility)
router.put('/companies/:companyId/settings', async (req, res) => {
    try {
        console.log('🔧 KB Settings PUT Request received:');
        console.log('📦 Company ID:', req.params.companyId);
        console.log('📦 Request Body:', JSON.stringify(req.body, null, 2));
        console.log('📦 Request Headers:', req.headers['content-type']);
        
        const { companyId } = req.params;
        const { reviewFrequency, confidenceThreshold, lastUpdated, version } = req.body;

        console.log('🔍 Extracted values:', {
            reviewFrequency,
            confidenceThreshold,
            lastUpdated,
            version
        });

        console.log('🔍 Looking up company with ID:', companyId);
        const company = await Company.findById(companyId);
        if (!company) {
            console.error('❌ Company not found:', companyId);
            return res.status(404).json({ success: false, message: 'Company not found' });
        }
        console.log('✅ Company found:', company.companyName || 'Unnamed Company');

        console.log('🔍 Current companyKBSettings before update:', JSON.stringify(company.companyKBSettings, null, 2));

        // Initialize companyKBSettings with proper schema defaults if it doesn't exist
        if (!company.companyKBSettings) {
            console.log('🆕 Initializing new companyKBSettings');
            company.companyKBSettings = {
                enabled: true,
                requireApproval: true,
                maxQuestions: 100,
                confidenceThreshold: 0.80,
                fuzzyMatchEnabled: true,
                fuzzyMatchThreshold: 0.85,
                priorityWeights: {
                    high: 1.0,
                    normal: 0.8,
                    low: 0.6
                },
                autoSuggestFromTradeKB: true,
                analytics: {
                    trackUsage: true,
                    trackPerformance: true,
                    generateReports: true
                }
            };
        }

        // Ensure nested objects exist with defaults
        if (!company.companyKBSettings.priorityWeights) {
            console.log('🔧 Adding missing priorityWeights');
            company.companyKBSettings.priorityWeights = {
                high: 1.0,
                normal: 0.8,
                low: 0.6
            };
        }

        if (!company.companyKBSettings.analytics) {
            console.log('🔧 Adding missing analytics');
            company.companyKBSettings.analytics = {
                trackUsage: true,
                trackPerformance: true,
                generateReports: true
            };
        }

        console.log('📝 About to update settings...');
        // Update only the settings provided in the request
        if (reviewFrequency !== undefined) {
            console.log('📝 Updating reviewFrequency from', company.companyKBSettings.reviewFrequency, 'to', reviewFrequency);
            company.companyKBSettings.reviewFrequency = reviewFrequency;
        }
        if (confidenceThreshold !== undefined) {
            console.log('📝 Updating confidenceThreshold from', company.companyKBSettings.confidenceThreshold, 'to', confidenceThreshold);
            company.companyKBSettings.confidenceThreshold = confidenceThreshold;
        }
        if (lastUpdated !== undefined) {
            console.log('📝 Updating lastUpdated to', lastUpdated);
            company.companyKBSettings.lastUpdated = lastUpdated;
        }
        if (version !== undefined) {
            console.log('📝 Updating version to', version);
            company.companyKBSettings.version = version;
        }

        console.log('📝 Final settings object before save:', JSON.stringify(company.companyKBSettings, null, 2));

        // Use findByIdAndUpdate to only update companyKBSettings field to avoid other validation issues
        console.log('💾 Executing database update...');
        const updatedCompany = await Company.findByIdAndUpdate(
            companyId,
            { $set: { companyKBSettings: company.companyKBSettings } },
            { new: true, runValidators: false } // Skip validators to avoid other field issues
        );

        console.log('✅ Database update completed');
        console.log('✅ Updated company KB settings in DB:', JSON.stringify(updatedCompany.companyKBSettings, null, 2));

        res.json({
            success: true,
            data: updatedCompany.companyKBSettings,
            message: 'Company KB settings updated successfully',
            debug: {
                originalSettings: req.body,
                finalSettings: updatedCompany.companyKBSettings,
                timestamp: new Date().toISOString()
            }
        });

    } catch (error) {
        console.error('❌ CRITICAL ERROR updating company KB settings:', error);
        console.error('❌ Error name:', error.name);
        console.error('❌ Error message:', error.message);
        console.error('❌ Error stack:', error.stack);
        console.error('❌ Request body that caused error:', JSON.stringify(req.body, null, 2));
        
        res.status(500).json({ 
            success: false, 
            message: 'Server error', 
            error: error.message,
            debug: {
                companyId: req.params.companyId,
                requestBody: req.body,
                timestamp: new Date().toISOString()
            }
        });
    }
});

// GET endpoint for company KB settings (alternative route for frontend compatibility)
router.get('/companies/:companyId/settings', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        // Ensure we have a complete settings object with proper defaults
        const defaultSettings = {
            enabled: true,
            requireApproval: true,
            maxQuestions: 100,
            confidenceThreshold: 0.80,
            fuzzyMatchEnabled: true,
            fuzzyMatchThreshold: 0.85,
            priorityWeights: {
                high: 1.0,
                normal: 0.8,
                low: 0.6
            },
            autoSuggestFromTradeKB: true,
            analytics: {
                trackUsage: true,
                trackPerformance: true,
                generateReports: true
            },
            entryCount: company.companyKB?.length || 0
        };

        // Merge existing settings with defaults
        const settings = company.companyKBSettings ? 
            { ...defaultSettings, ...company.companyKBSettings.toObject() } : 
            defaultSettings;

        // Ensure entry count is current
        settings.entryCount = company.companyKB?.length || 0;

        res.json({
            success: true,
            data: settings
        });

    } catch (error) {
        console.error('Error fetching company KB settings:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Regenerate keywords for existing Company KB entries
router.post('/companies/:companyId/company-kb/:qaId/regenerate-keywords', async (req, res) => {
    try {
        const { companyId, qaId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        const qaIndex = company.companyKB?.findIndex(qa => qa.id === qaId);
        if (qaIndex === -1) {
            return res.status(404).json({ success: false, message: 'Q&A entry not found' });
        }

        const qa = company.companyKB[qaIndex];
        
        // Regenerate keywords
        const keywordGeneration = generateKeywords(qa.question, qa.answer, []);
        const newIntent = suggestIntent(qa.question, qa.answer);
        
        // Update the Q&A entry
        company.companyKB[qaIndex] = {
            ...qa,
            keywords: keywordGeneration.keywords,
            negativeKeywords: keywordGeneration.suggestedNegativeKeywords,
            intent: newIntent,
            metadata: {
                ...qa.metadata,
                updatedAt: new Date(),
                keywordConfidence: keywordGeneration.confidence,
                autoGenerated: true
            }
        };

        await company.save();

        res.json({
            success: true,
            data: company.companyKB[qaIndex],
            message: 'Keywords regenerated successfully',
            analysis: {
                keywordsGenerated: keywordGeneration.keywords.length,
                confidence: keywordGeneration.confidence,
                intent: newIntent
            }
        });

    } catch (error) {
        console.error('Error regenerating keywords:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

// Bulk regenerate keywords for all Company KB entries
router.post('/companies/:companyId/company-kb/bulk-regenerate-keywords', async (req, res) => {
    try {
        const { companyId } = req.params;

        const company = await Company.findById(companyId);
        if (!company) {
            return res.status(404).json({ success: false, message: 'Company not found' });
        }

        if (!company.companyKB || company.companyKB.length === 0) {
            return res.status(400).json({ success: false, message: 'No Q&A entries found' });
        }

        let updatedCount = 0;
        const results = [];

        // Process each Q&A entry
        company.companyKB.forEach((qa, index) => {
            const keywordGeneration = generateKeywords(qa.question, qa.answer, []);
            const newIntent = suggestIntent(qa.question, qa.answer);
            
            company.companyKB[index] = {
                ...qa,
                keywords: keywordGeneration.keywords,
                negativeKeywords: keywordGeneration.suggestedNegativeKeywords,
                intent: newIntent,
                metadata: {
                    ...qa.metadata,
                    updatedAt: new Date(),
                    keywordConfidence: keywordGeneration.confidence,
                    autoGenerated: true
                }
            };

            updatedCount++;
            results.push({
                id: qa.id,
                question: qa.question.substring(0, 50) + '...',
                keywordsGenerated: keywordGeneration.keywords.length,
                confidence: keywordGeneration.confidence,
                intent: newIntent
            });
        });

        await company.save();

        res.json({
            success: true,
            message: `Keywords regenerated for ${updatedCount} Q&A entries`,
            data: {
                updatedCount,
                totalEntries: company.companyKB.length,
                results
            }
        });

    } catch (error) {
        console.error('Error bulk regenerating keywords:', error);
        res.status(500).json({ success: false, message: 'Server error', error: error.message });
    }
});

module.exports = router;
