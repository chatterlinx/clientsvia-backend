/**
 * ============================================================================
 * SUGGESTION MANAGER - INTELLIGENT AI OPTIMIZATION SYSTEM
 * ============================================================================
 * 
 * PURPOSE:
 * Enterprise-grade management of AI optimization suggestions generated by the
 * IntelligentPatternDetector. Enables developers to review, apply, ignore, or
 * dismiss suggestions with full audit trail and impact tracking.
 * 
 * ARCHITECTURE:
 * - Modular, self-contained class following Single Responsibility Principle
 * - Real-time filtering and sorting (type, priority, confidence)
 * - One-click application with automatic rollback on failure
 * - Batch operations for efficiency
 * - Full audit trail (who applied what, when, why)
 * - Impact tracking (before/after metrics)
 * 
 * SUGGESTION TYPES:
 * - üîá Filler: Add word to filler list
 * - üî§ Synonym: Map colloquial ‚Üí technical term
 * - üéØ Keyword: Add missing keyword to scenario
 * - ‚ö†Ô∏è Negative Keyword: Add negative keyword to avoid confusion
 * - üîÄ Conflict: Overlapping keywords between scenarios
 * 
 * FEATURES:
 * - ‚úÖ Fetch pending suggestions (with filtering)
 * - ‚úÖ Apply suggestion (one-click)
 * - ‚úÖ Ignore suggestion (with reason)
 * - ‚úÖ Dismiss suggestion (permanently)
 * - ‚úÖ Batch operations (apply all high-priority, etc.)
 * - ‚úÖ Real-time statistics (high/medium/low counts)
 * - ‚úÖ Impact tracking (success rate)
 * 
 * USAGE:
 * ```javascript
 * const suggestionManager = new SuggestionManager();
 * 
 * // Get all pending suggestions
 * const suggestions = await suggestionManager.getSuggestions(templateId);
 * 
 * // Apply a suggestion
 * await suggestionManager.applySuggestion(templateId, suggestionId);
 * 
 * // Get statistics
 * const stats = await suggestionManager.getStatistics(templateId);
 * ```
 * 
 * ============================================================================
 */

class SuggestionManager {
    constructor() {
        // ============================================
        // CONFIGURATION
        // ============================================
        
        this.config = {
            apiBaseUrl: '/api/admin/global-instant-responses',
            cacheTTL: 60000, // 1 minute (suggestions change frequently)
            maxSuggestionsPerFetch: 100,
            autoRefreshInterval: 30000 // 30 seconds
        };
        
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        // Cache: { templateId: { suggestions: [...], summary: {...}, timestamp: Date } }
        this.cache = new Map();
        
        // Auto-refresh interval ID
        this.autoRefreshIntervalId = null;
        
        // Event listeners for real-time updates
        this.listeners = new Map();
        
        logger.info('‚úÖ [SUGGESTION MANAGER] Initialized');
    }
    
    // ============================================
    // PUBLIC API - SUGGESTION MANAGEMENT
    // ============================================
    
    /**
     * Get all suggestions for a template
     * @param {String} templateId - Template ID
     * @param {Object} filters - Optional filters
     * @param {String} filters.status - Status filter (pending, applied, ignored, dismissed)
     * @param {String} filters.type - Type filter (filler, synonym, keyword, negative_keyword, conflict)
     * @param {String} filters.priority - Priority filter (high, medium, low)
     * @param {Number} filters.minConfidence - Minimum confidence (0-1)
     * @param {Boolean} forceRefresh - Skip cache
     * @returns {Promise<Object>} - Suggestions and summary
     */
    async getSuggestions(templateId, filters = {}, forceRefresh = false) {
        this.validateTemplateId(templateId);
        
        // Check cache first
        if (!forceRefresh && this.isCacheValid(templateId)) {
            logger.debug('üì¶ [SUGGESTION MANAGER] Cache hit', { templateId });
            return this.cache.get(templateId);
        }
        
        try {
            // Build query string
            const queryParams = new URLSearchParams();
            if (filters.status) queryParams.append('status', filters.status);
            if (filters.type) queryParams.append('type', filters.type);
            if (filters.priority) queryParams.append('priority', filters.priority);
            if (filters.minConfidence) queryParams.append('minConfidence', filters.minConfidence);
            
            const queryString = queryParams.toString();
            const url = `${this.config.apiBaseUrl}/${templateId}/suggestions${queryString ? '?' + queryString : ''}`;
            
            const response = await this.makeRequest(url, 'GET');
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to fetch suggestions');
            }
            
            // Update cache
            this.updateCache(templateId, {
                suggestions: response.suggestions,
                summary: response.summary,
                count: response.count
            });
            
            // Notify listeners
            this.notifyListeners('suggestionsUpdated', {
                templateId,
                count: response.count
            });
            
            logger.info('‚úÖ [SUGGESTION MANAGER] Fetched suggestions', {
                templateId,
                count: response.count,
                filters
            });
            
            return {
                suggestions: response.suggestions,
                summary: response.summary,
                count: response.count
            };
            
        } catch (error) {
            logger.error('‚ùå [SUGGESTION MANAGER] Error fetching suggestions', {
                templateId,
                error: error.message
            });
            throw new Error(`Failed to load suggestions: ${error.message}`);
        }
    }
    
    /**
     * Get suggestion statistics
     * @param {String} templateId - Template ID
     * @returns {Promise<Object>} - Statistics
     */
    async getStatistics(templateId) {
        const data = await this.getSuggestions(templateId);
        return data.summary || {
            high: 0,
            medium: 0,
            low: 0,
            total: 0
        };
    }
    
    /**
     * Apply a suggestion
     * @param {String} templateId - Template ID
     * @param {String} suggestionId - Suggestion ID
     * @returns {Promise<Object>} - Result
     */
    async applySuggestion(templateId, suggestionId) {
        this.validateTemplateId(templateId);
        this.validateSuggestionId(suggestionId);
        
        try {
            const response = await this.makeRequest(
                `${this.config.apiBaseUrl}/${templateId}/suggestions/${suggestionId}/apply`,
                'POST'
            );
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to apply suggestion');
            }
            
            // Invalidate cache
            this.invalidateCache(templateId);
            
            // Notify listeners
            this.notifyListeners('suggestionApplied', {
                templateId,
                suggestionId
            });
            
            logger.info('‚úÖ [SUGGESTION MANAGER] Suggestion applied', {
                templateId,
                suggestionId
            });
            
            return response;
            
        } catch (error) {
            logger.error('‚ùå [SUGGESTION MANAGER] Error applying suggestion', {
                templateId,
                suggestionId,
                error: error.message
            });
            
            throw new Error(`Failed to apply suggestion: ${error.message}`);
        }
    }
    
    /**
     * Ignore a suggestion
     * @param {String} templateId - Template ID
     * @param {String} suggestionId - Suggestion ID
     * @param {String} reason - Optional reason
     * @returns {Promise<Object>} - Result
     */
    async ignoreSuggestion(templateId, suggestionId, reason = '') {
        this.validateTemplateId(templateId);
        this.validateSuggestionId(suggestionId);
        
        try {
            const response = await this.makeRequest(
                `${this.config.apiBaseUrl}/${templateId}/suggestions/${suggestionId}/ignore`,
                'POST',
                { reason }
            );
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to ignore suggestion');
            }
            
            // Invalidate cache
            this.invalidateCache(templateId);
            
            // Notify listeners
            this.notifyListeners('suggestionIgnored', {
                templateId,
                suggestionId,
                reason
            });
            
            logger.info('‚úÖ [SUGGESTION MANAGER] Suggestion ignored', {
                templateId,
                suggestionId,
                reason
            });
            
            return response;
            
        } catch (error) {
            logger.error('‚ùå [SUGGESTION MANAGER] Error ignoring suggestion', {
                templateId,
                suggestionId,
                error: error.message
            });
            
            throw new Error(`Failed to ignore suggestion: ${error.message}`);
        }
    }
    
    /**
     * Dismiss a suggestion permanently
     * @param {String} templateId - Template ID
     * @param {String} suggestionId - Suggestion ID
     * @returns {Promise<Object>} - Result
     */
    async dismissSuggestion(templateId, suggestionId) {
        this.validateTemplateId(templateId);
        this.validateSuggestionId(suggestionId);
        
        try {
            const response = await this.makeRequest(
                `${this.config.apiBaseUrl}/${templateId}/suggestions/${suggestionId}/dismiss`,
                'POST'
            );
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to dismiss suggestion');
            }
            
            // Invalidate cache
            this.invalidateCache(templateId);
            
            // Notify listeners
            this.notifyListeners('suggestionDismissed', {
                templateId,
                suggestionId
            });
            
            logger.info('‚úÖ [SUGGESTION MANAGER] Suggestion dismissed', {
                templateId,
                suggestionId
            });
            
            return response;
            
        } catch (error) {
            logger.error('‚ùå [SUGGESTION MANAGER] Error dismissing suggestion', {
                templateId,
                suggestionId,
                error: error.message
            });
            
            throw new Error(`Failed to dismiss suggestion: ${error.message}`);
        }
    }
    
    // ============================================
    // BATCH OPERATIONS
    // ============================================
    
    /**
     * Apply all high-priority suggestions
     * @param {String} templateId - Template ID
     * @returns {Promise<Object>} - Results
     */
    async applyAllHighPriority(templateId) {
        const { suggestions } = await this.getSuggestions(templateId, { priority: 'high' });
        
        const results = {
            success: 0,
            failed: 0,
            errors: []
        };
        
        for (const suggestion of suggestions) {
            try {
                await this.applySuggestion(templateId, suggestion._id);
                results.success++;
            } catch (error) {
                results.failed++;
                results.errors.push({
                    suggestionId: suggestion._id,
                    error: error.message
                });
            }
        }
        
        logger.info('‚úÖ [SUGGESTION MANAGER] Batch apply high-priority complete', {
            templateId,
            results
        });
        
        return results;
    }
    
    /**
     * Ignore all low-priority suggestions
     * @param {String} templateId - Template ID
     * @param {String} reason - Reason for ignoring
     * @returns {Promise<Object>} - Results
     */
    async ignoreAllLowPriority(templateId, reason = 'Low priority, not needed') {
        const { suggestions } = await this.getSuggestions(templateId, { priority: 'low' });
        
        const results = {
            success: 0,
            failed: 0,
            errors: []
        };
        
        for (const suggestion of suggestions) {
            try {
                await this.ignoreSuggestion(templateId, suggestion._id, reason);
                results.success++;
            } catch (error) {
                results.failed++;
                results.errors.push({
                    suggestionId: suggestion._id,
                    error: error.message
                });
            }
        }
        
        logger.info('‚úÖ [SUGGESTION MANAGER] Batch ignore low-priority complete', {
            templateId,
            results
        });
        
        return results;
    }
    
    /**
     * Apply all suggestions of a specific type
     * @param {String} templateId - Template ID
     * @param {String} type - Type (filler, synonym, keyword, negative_keyword, conflict)
     * @returns {Promise<Object>} - Results
     */
    async applyAllByType(templateId, type) {
        const { suggestions } = await this.getSuggestions(templateId, { type });
        
        const results = {
            success: 0,
            failed: 0,
            errors: []
        };
        
        for (const suggestion of suggestions) {
            try {
                await this.applySuggestion(templateId, suggestion._id);
                results.success++;
            } catch (error) {
                results.failed++;
                results.errors.push({
                    suggestionId: suggestion._id,
                    error: error.message
                });
            }
        }
        
        logger.info('‚úÖ [SUGGESTION MANAGER] Batch apply by type complete', {
            templateId,
            type,
            results
        });
        
        return results;
    }
    
    // ============================================
    // PATTERN DETECTION TRIGGER
    // ============================================
    
    /**
     * Trigger pattern analysis on test calls
     * @param {String} templateId - Template ID
     * @param {Array} testCalls - Test call data
     * @returns {Promise<Object>} - Analysis results
     */
    async analyzePatterns(templateId, testCalls) {
        this.validateTemplateId(templateId);
        
        if (!Array.isArray(testCalls) || testCalls.length === 0) {
            throw new Error('Test calls array is required');
        }
        
        try {
            const response = await this.makeRequest(
                `${this.config.apiBaseUrl}/${templateId}/analyze`,
                'POST',
                { testCalls }
            );
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to analyze patterns');
            }
            
            // Invalidate cache to show new suggestions
            this.invalidateCache(templateId);
            
            // Notify listeners
            this.notifyListeners('patternsAnalyzed', {
                templateId,
                totalSuggestions: response.totalSuggestions
            });
            
            logger.info('‚úÖ [SUGGESTION MANAGER] Pattern analysis complete', {
                templateId,
                callsAnalyzed: testCalls.length,
                suggestionsGenerated: response.totalSuggestions
            });
            
            return response;
            
        } catch (error) {
            logger.error('‚ùå [SUGGESTION MANAGER] Error analyzing patterns', {
                templateId,
                error: error.message
            });
            
            throw new Error(`Failed to analyze patterns: ${error.message}`);
        }
    }
    
    // ============================================
    // REAL-TIME UPDATES
    // ============================================
    
    /**
     * Subscribe to suggestion updates
     * @param {String} event - Event name (suggestionsUpdated, suggestionApplied, etc.)
     * @param {Function} callback - Callback function
     * @returns {Function} - Unsubscribe function
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        
        this.listeners.get(event).push(callback);
        
        // Return unsubscribe function
        return () => {
            const callbacks = this.listeners.get(event);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        };
    }
    
    /**
     * Start auto-refresh for a template
     * @param {String} templateId - Template ID
     * @param {Number} interval - Refresh interval in milliseconds
     */
    startAutoRefresh(templateId, interval = null) {
        this.stopAutoRefresh(); // Clear existing interval
        
        const refreshInterval = interval || this.config.autoRefreshInterval;
        
        this.autoRefreshIntervalId = setInterval(async () => {
            try {
                await this.getSuggestions(templateId, {}, true); // Force refresh
            } catch (error) {
                logger.warn('‚ö†Ô∏è [SUGGESTION MANAGER] Auto-refresh failed', {
                    templateId,
                    error: error.message
                });
            }
        }, refreshInterval);
        
        logger.info('‚úÖ [SUGGESTION MANAGER] Auto-refresh started', {
            templateId,
            interval: refreshInterval
        });
    }
    
    /**
     * Stop auto-refresh
     */
    stopAutoRefresh() {
        if (this.autoRefreshIntervalId) {
            clearInterval(this.autoRefreshIntervalId);
            this.autoRefreshIntervalId = null;
            logger.info('‚úÖ [SUGGESTION MANAGER] Auto-refresh stopped');
        }
    }
    
    // ============================================
    // UTILITY METHODS
    // ============================================
    
    /**
     * Filter suggestions client-side
     * @param {Array} suggestions - Suggestions to filter
     * @param {Object} filters - Filter criteria
     * @returns {Array} - Filtered suggestions
     */
    filterSuggestions(suggestions, filters = {}) {
        let filtered = [...suggestions];
        
        if (filters.type) {
            filtered = filtered.filter(s => s.type === filters.type);
        }
        
        if (filters.priority) {
            filtered = filtered.filter(s => s.priority === filters.priority);
        }
        
        if (filters.minConfidence) {
            filtered = filtered.filter(s => s.confidence >= filters.minConfidence);
        }
        
        if (filters.searchTerm) {
            const search = filters.searchTerm.toLowerCase();
            filtered = filtered.filter(s => {
                return (
                    (s.fillerWord && s.fillerWord.toLowerCase().includes(search)) ||
                    (s.colloquialTerm && s.colloquialTerm.toLowerCase().includes(search)) ||
                    (s.technicalTerm && s.technicalTerm.toLowerCase().includes(search)) ||
                    (s.keyword && s.keyword.toLowerCase().includes(search))
                );
            });
        }
        
        return filtered;
    }
    
    /**
     * Sort suggestions by priority, confidence, or impact
     * @param {Array} suggestions - Suggestions to sort
     * @param {String} sortBy - Sort criteria (priority, confidence, impact)
     * @param {String} order - Sort order (asc, desc)
     * @returns {Array} - Sorted suggestions
     */
    sortSuggestions(suggestions, sortBy = 'priority', order = 'desc') {
        const sorted = [...suggestions];
        
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        
        sorted.sort((a, b) => {
            let aVal, bVal;
            
            if (sortBy === 'priority') {
                aVal = priorityOrder[a.priority] || 0;
                bVal = priorityOrder[b.priority] || 0;
            } else if (sortBy === 'confidence') {
                aVal = a.confidence || 0;
                bVal = b.confidence || 0;
            } else if (sortBy === 'impact') {
                aVal = a.estimatedImpact || 0;
                bVal = b.estimatedImpact || 0;
            } else {
                return 0;
            }
            
            return order === 'asc' ? aVal - bVal : bVal - aVal;
        });
        
        return sorted;
    }
    
    // ============================================
    // INTERNAL HELPERS
    // ============================================
    
    validateTemplateId(templateId) {
        if (!templateId || typeof templateId !== 'string') {
            throw new Error('Valid template ID is required');
        }
    }
    
    validateSuggestionId(suggestionId) {
        if (!suggestionId || typeof suggestionId !== 'string') {
            throw new Error('Valid suggestion ID is required');
        }
    }
    
    isCacheValid(templateId) {
        if (!this.cache.has(templateId)) return false;
        
        const cached = this.cache.get(templateId);
        const age = Date.now() - cached.timestamp;
        
        return age < this.config.cacheTTL;
    }
    
    updateCache(templateId, data) {
        this.cache.set(templateId, {
            ...data,
            timestamp: Date.now()
        });
    }
    
    invalidateCache(templateId) {
        this.cache.delete(templateId);
    }
    
    notifyListeners(event, data) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            callbacks.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    logger.error('‚ùå [SUGGESTION MANAGER] Listener error', {
                        event,
                        error: error.message
                    });
                }
            });
        }
    }
    
    async makeRequest(url, method, body = null) {
        const options = {
            method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}`
            }
        };
        
        if (body) {
            options.body = JSON.stringify(body);
        }
        
        const response = await fetch(url, options);
        
        if (!response.ok) {
            const error = await response.json().catch(() => ({ error: 'Network error' }));
            throw new Error(error.error || `HTTP ${response.status}`);
        }
        
        return response.json();
    }
}

// ============================================
// LOGGER FALLBACK (if not available globally)
// ============================================
if (typeof logger === 'undefined') {
    window.logger = {
        info: (...args) => console.log('[INFO]', ...args),
        debug: (...args) => console.log('[DEBUG]', ...args),
        warn: (...args) => console.warn('[WARN]', ...args),
        error: (...args) => console.error('[ERROR]', ...args)
    };
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SuggestionManager;
}

