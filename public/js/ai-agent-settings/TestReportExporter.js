/**
 * ============================================================================
 * TEST REPORT EXPORTER - BEAUTIFUL TEST REPORT GENERATION
 * ============================================================================
 * 
 * PURPOSE:
 * Enterprise-grade test report generation for the ClientsVia AI Testing System.
 * Transforms raw test results into beautiful, shareable reports in multiple formats.
 * Enables developers to document, share, and track AI performance over time.
 * 
 * ARCHITECTURE:
 * - Modular, self-contained class following Single Responsibility Principle
 * - Multiple output formats (Markdown, JSON, HTML preview)
 * - Copy-to-clipboard with fallback for older browsers
 * - Export to file (download)
 * - Comprehensive metrics and recommendations
 * - Comparison mode (before/after improvements)
 * 
 * OUTPUT FORMATS:
 * - üìù Markdown: GitHub-ready, perfect for documentation
 * - üìä JSON: Programmatic analysis, CI/CD integration
 * - üåê HTML: Preview in browser, printable
 * - üìÑ Text: Plain text for email, chat
 * 
 * FEATURES:
 * - ‚úÖ Generate report from test results
 * - ‚úÖ Copy to clipboard (one-click)
 * - ‚úÖ Download as file
 * - ‚úÖ Multiple formats
 * - ‚úÖ Intelligent recommendations
 * - ‚úÖ Before/after comparison
 * - ‚úÖ Visual pass/fail indicators
 * - ‚úÖ Performance metrics
 * 
 * USAGE:
 * ```javascript
 * const exporter = new TestReportExporter();
 * 
 * // Generate Markdown report
 * const markdown = exporter.generateMarkdown(templateName, testResults);
 * 
 * // Copy to clipboard
 * await exporter.copyToClipboard(markdown);
 * 
 * // Download as file
 * exporter.downloadReport(markdown, 'test-report.md');
 * ```
 * 
 * ============================================================================
 */

class TestReportExporter {
    constructor() {
        // ============================================
        // CONFIGURATION
        // ============================================
        
        this.config = {
            apiBaseUrl: '/api/admin/global-instant-responses',
            maxFailedTestsToShow: 20,
            maxPassedTestsToShow: 50
        };
        
        logger.info('‚úÖ [TEST REPORT EXPORTER] Initialized');
    }
    
    // ============================================
    // MARKDOWN GENERATION
    // ============================================
    
    /**
     * Generate Markdown test report
     * @param {String} templateName - Template name
     * @param {Object} testResults - Test results object
     * @param {Object} options - Optional settings
     * @returns {String} - Markdown string
     */
    generateMarkdown(templateName, testResults, options = {}) {
        const tests = testResults.tests || [];
        const passed = tests.filter(t => t.matched).length;
        const failed = tests.filter(t => !t.matched).length;
        const avgConfidence = tests.length > 0
            ? tests.reduce((sum, t) => sum + (t.confidence || 0), 0) / tests.length
            : 0;
        
        let markdown = '';
        
        // Header
        markdown += this.generateMarkdownHeader(templateName, options);
        
        // Summary
        markdown += this.generateMarkdownSummary(tests.length, passed, failed, avgConfidence);
        
        // Failed tests (detailed)
        if (failed > 0) {
            markdown += this.generateMarkdownFailedTests(tests, options);
        }
        
        // Passed tests (summary)
        markdown += this.generateMarkdownPassedTests(tests, options);
        
        // Recommendations
        markdown += this.generateMarkdownRecommendations(tests, passed, failed, avgConfidence);
        
        // Footer
        markdown += this.generateMarkdownFooter();
        
        return markdown;
    }
    
    generateMarkdownHeader(templateName, options = {}) {
        const now = new Date().toISOString();
        const username = options.username || 'System';
        
        let header = `# üß™ AI Test Report - ${templateName}\n\n`;
        header += `**Generated:** ${now}  \n`;
        header += `**Generated By:** ${username}  \n`;
        
        if (options.templateId) {
            header += `**Template ID:** ${options.templateId}  \n`;
        }
        
        if (options.version) {
            header += `**Template Version:** ${options.version}  \n`;
        }
        
        header += `\n---\n\n`;
        
        return header;
    }
    
    generateMarkdownSummary(total, passed, failed, avgConfidence) {
        const passRate = total > 0 ? (passed / total) * 100 : 0;
        const failRate = total > 0 ? (failed / total) * 100 : 0;
        
        let summary = `## üìä Test Summary\n\n`;
        summary += `| Metric | Value |\n`;
        summary += `|--------|-------|\n`;
        summary += `| Total Tests | ${total} |\n`;
        summary += `| ‚úÖ Passed | ${passed} (${passRate.toFixed(1)}%) |\n`;
        summary += `| ‚ùå Failed | ${failed} (${failRate.toFixed(1)}%) |\n`;
        summary += `| üìà Avg Confidence | ${(avgConfidence * 100).toFixed(1)}% |\n\n`;
        
        return summary;
    }
    
    generateMarkdownFailedTests(tests, options = {}) {
        const failedTests = tests.filter(t => !t.matched);
        const maxToShow = options.maxFailedTests || this.config.maxFailedTestsToShow;
        const testsToShow = failedTests.slice(0, maxToShow);
        
        let section = `---\n\n`;
        section += `## ‚ùå Failed Tests\n\n`;
        
        if (failedTests.length > maxToShow) {
            section += `*Showing ${maxToShow} of ${failedTests.length} failed tests*\n\n`;
        }
        
        testsToShow.forEach((test, idx) => {
            section += `### ${idx + 1}. ${test.phrase || 'Unknown phrase'}\n\n`;
            section += `**Expected:** ${test.expectedScenario || 'N/A'}  \n`;
            section += `**Actual:** ${test.matchedScenario || 'No match'}  \n`;
            section += `**Confidence:** ${((test.confidence || 0) * 100).toFixed(1)}%  \n\n`;
            
            if (test.trace) {
                section += `**Debug Info:**\n`;
                section += `- Normalized: \`${test.trace.normalizedPhrase || ''}\`\n`;
                section += `- Terms: ${test.trace.phraseTerms?.length || 0}\n`;
                
                if (test.trace.topCandidates && test.trace.topCandidates.length > 0) {
                    section += `- Top Candidates:\n`;
                    test.trace.topCandidates.slice(0, 3).forEach(c => {
                        section += `  - ${c.name} (${(c.confidence * 100).toFixed(0)}%)\n`;
                    });
                }
                
                section += `\n`;
            }
        });
        
        return section;
    }
    
    generateMarkdownPassedTests(tests, options = {}) {
        const passedTests = tests.filter(t => t.matched);
        const maxToShow = options.maxPassedTests || this.config.maxPassedTestsToShow;
        const testsToShow = passedTests.slice(0, maxToShow);
        
        let section = `---\n\n`;
        section += `## ‚úÖ Passed Tests\n\n`;
        
        if (passedTests.length > maxToShow) {
            section += `*Showing ${maxToShow} of ${passedTests.length} passed tests*\n\n`;
        }
        
        testsToShow.forEach((test, idx) => {
            const phrasePreview = (test.phrase || '').substring(0, 60);
            const ellipsis = test.phrase && test.phrase.length > 60 ? '...' : '';
            const confidence = ((test.confidence || 0) * 100).toFixed(0);
            
            section += `${idx + 1}. **${phrasePreview}${ellipsis}** ‚Üí ${test.matchedScenario} (${confidence}%)\n`;
        });
        
        section += `\n`;
        
        return section;
    }
    
    generateMarkdownRecommendations(tests, passed, failed, avgConfidence) {
        let section = `---\n\n`;
        section += `## üîç Recommendations\n\n`;
        
        const recommendations = [];
        
        // Failed tests
        if (failed > 0) {
            const percentage = ((failed / tests.length) * 100).toFixed(1);
            recommendations.push(`- **${failed} tests failed (${percentage}%).** Review normalized inputs and add missing keywords.`);
        }
        
        // Low confidence
        if (avgConfidence < 0.7) {
            recommendations.push(`- **Low average confidence (${(avgConfidence * 100).toFixed(1)}%).** Consider adding more keywords or synonyms.`);
        }
        
        // Very low confidence
        if (avgConfidence < 0.5) {
            recommendations.push(`- **Very low confidence!** Check for conflicting keywords or missing scenario triggers.`);
        }
        
        // High failure rate
        if (failed > tests.length * 0.3) {
            recommendations.push(`- **High failure rate!** Consider running pattern analysis to auto-detect improvements.`);
        }
        
        // Excellent performance
        if (failed === 0 && avgConfidence >= 0.8) {
            recommendations.push(`- **üéâ Excellent performance!** All tests passed with high confidence.`);
        }
        
        // Good performance
        if (failed === 0 && avgConfidence >= 0.6 && avgConfidence < 0.8) {
            recommendations.push(`- **Good performance!** All tests passed. Consider fine-tuning to increase confidence.`);
        }
        
        // Add recommendations
        if (recommendations.length > 0) {
            recommendations.forEach(rec => {
                section += `${rec}\n`;
            });
        } else {
            section += `- No specific recommendations. Continue monitoring performance.\n`;
        }
        
        section += `\n`;
        
        return section;
    }
    
    generateMarkdownFooter() {
        return `---\n\n*Report generated by ClientsVia AI Testing System*\n`;
    }
    
    // ============================================
    // JSON GENERATION
    // ============================================
    
    /**
     * Generate JSON test report
     * @param {String} templateId - Template ID
     * @param {String} templateName - Template name
     * @param {Object} testResults - Test results object
     * @param {Object} options - Optional settings
     * @returns {String} - JSON string
     */
    generateJSON(templateId, templateName, testResults, options = {}) {
        const tests = testResults.tests || [];
        const passed = tests.filter(t => t.matched).length;
        const failed = tests.filter(t => !t.matched).length;
        const avgConfidence = tests.length > 0
            ? tests.reduce((sum, t) => sum + (t.confidence || 0), 0) / tests.length
            : 0;
        
        const report = {
            template: {
                id: templateId,
                name: templateName,
                version: options.version || 1
            },
            metadata: {
                generatedAt: new Date().toISOString(),
                generatedBy: options.username || 'System',
                reportVersion: '1.0'
            },
            summary: {
                totalTests: tests.length,
                passed,
                failed,
                passRate: tests.length > 0 ? (passed / tests.length) : 0,
                avgConfidence
            },
            tests: tests.map(test => ({
                phrase: test.phrase,
                expectedScenario: test.expectedScenario,
                matchedScenario: test.matchedScenario,
                matched: test.matched,
                confidence: test.confidence,
                trace: test.trace || null
            })),
            failedTests: tests.filter(t => !t.matched),
            passedTests: tests.filter(t => t.matched),
            recommendations: this.generateRecommendationsArray(tests, passed, failed, avgConfidence)
        };
        
        return JSON.stringify(report, null, 2);
    }
    
    generateRecommendationsArray(tests, passed, failed, avgConfidence) {
        const recommendations = [];
        
        if (failed > 0) {
            recommendations.push({
                type: 'failed_tests',
                severity: 'high',
                message: `${failed} tests failed. Review normalized inputs and add missing keywords.`
            });
        }
        
        if (avgConfidence < 0.7) {
            recommendations.push({
                type: 'low_confidence',
                severity: avgConfidence < 0.5 ? 'critical' : 'medium',
                message: `Average confidence is ${(avgConfidence * 100).toFixed(1)}%. Consider adding more keywords or synonyms.`
            });
        }
        
        if (failed === 0 && avgConfidence >= 0.8) {
            recommendations.push({
                type: 'success',
                severity: 'INFO',
                message: 'Excellent performance! All tests passed with high confidence.'
            });
        }
        
        return recommendations;
    }
    
    // ============================================
    // CLIPBOARD OPERATIONS
    // ============================================
    
    /**
     * Copy text to clipboard
     * @param {String} text - Text to copy
     * @returns {Promise<Boolean>} - Success
     */
    async copyToClipboard(text) {
        try {
            // Try modern Clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(text);
                logger.info('‚úÖ [TEST REPORT EXPORTER] Copied to clipboard (modern API)');
                return true;
            }
            
            // Fallback to older method
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile
            
            const success = document.execCommand('copy');
            document.body.removeChild(textarea);
            
            if (success) {
                logger.info('‚úÖ [TEST REPORT EXPORTER] Copied to clipboard (fallback method)');
                return true;
            } else {
                throw new Error('Copy command failed');
            }
            
        } catch (error) {
            logger.error('‚ùå [TEST REPORT EXPORTER] Failed to copy to clipboard', {
                error: error.message
            });
            throw new Error(`Failed to copy to clipboard: ${error.message}`);
        }
    }
    
    // ============================================
    // FILE DOWNLOAD
    // ============================================
    
    /**
     * Download report as file
     * @param {String} content - File content
     * @param {String} filename - Filename
     * @param {String} mimeType - MIME type
     */
    downloadReport(content, filename, mimeType = 'text/plain') {
        try {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Clean up
            setTimeout(() => URL.revokeObjectURL(url), 100);
            
            logger.info('‚úÖ [TEST REPORT EXPORTER] Downloaded report', { filename });
            
        } catch (error) {
            logger.error('‚ùå [TEST REPORT EXPORTER] Failed to download report', {
                error: error.message
            });
            throw new Error(`Failed to download report: ${error.message}`);
        }
    }
    
    // ============================================
    // HELPER METHODS
    // ============================================
    
    /**
     * Generate filename from template name and date
     * @param {String} templateName - Template name
     * @param {String} format - Format (markdown, json, html, txt)
     * @returns {String} - Filename
     */
    generateFilename(templateName, format = 'markdown') {
        const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        const safeName = templateName.replace(/[^a-z0-9]/gi, '-').toLowerCase();
        const extensions = {
            markdown: 'md',
            json: 'json',
            html: 'html',
            txt: 'txt'
        };
        
        const ext = extensions[format] || 'txt';
        
        return `test-report-${safeName}-${date}.${ext}`;
    }
    
    /**
     * Get MIME type for format
     * @param {String} format - Format
     * @returns {String} - MIME type
     */
    getMimeType(format) {
        const mimeTypes = {
            markdown: 'text/markdown',
            json: 'application/json',
            html: 'text/html',
            txt: 'text/plain'
        };
        
        return mimeTypes[format] || 'text/plain';
    }
    
    /**
     * Generate report via API (backend-generated)
     * @param {String} templateId - Template ID
     * @param {Object} testResults - Test results
     * @param {String} format - Format (markdown or json)
     * @returns {Promise<String>} - Report content
     */
    async generateReportViaAPI(templateId, testResults, format = 'markdown') {
        try {
            const response = await this.makeRequest(
                `${this.config.apiBaseUrl}/${templateId}/test-report`,
                'POST',
                {
                    testResults,
                    format
                }
            );
            
            if (!response.success) {
                throw new Error(response.error || 'Failed to generate report');
            }
            
            logger.info('‚úÖ [TEST REPORT EXPORTER] Generated report via API', {
                templateId,
                format
            });
            
            return response.report;
            
        } catch (error) {
            logger.error('‚ùå [TEST REPORT EXPORTER] API generation failed', {
                error: error.message
            });
            throw new Error(`Failed to generate report via API: ${error.message}`);
        }
    }
    
    async makeRequest(url, method, body = null) {
        const options = {
            method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}`
            }
        };
        
        if (body) {
            options.body = JSON.stringify(body);
        }
        
        const response = await fetch(url, options);
        
        if (!response.ok) {
            const error = await response.json().catch(() => ({ error: 'Network error' }));
            throw new Error(error.error || `HTTP ${response.status}`);
        }
        
        return response.json();
    }
}

// ============================================
// LOGGER FALLBACK (if not available globally)
// ============================================
if (typeof logger === 'undefined') {
    window.logger = {
        info: (...args) => console.log('[INFO]', ...args),
        debug: (...args) => console.log('[DEBUG]', ...args),
        warn: (...args) => console.warn('[WARN]', ...args),
        error: (...args) => console.error('[ERROR]', ...args)
    };
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TestReportExporter;
}

